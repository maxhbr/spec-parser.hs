Spdx3Model {_profiles = fromList [("AI",Spdx3Profile {_profileSummary = "Additional metadata based on software profile, that is useful for ai\napplications and models.", _profileDescription = "The AI profile namespace defines concepts related to AI application and\nmodel artifacts.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3/AI"),("name","AI")], _profileProperties = fromList [("autonomyType",Spdx3Property {_propertySummary = "States if a human is involved in the decisions of the AI software.", _propertyDescription = "AutonomyType indicates if a human is involved in any of the decisions of\nthe AI software or if that software is fully automatic.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","PresenceType"),("name","autonomyType")]}),("domain",Spdx3Property {_propertySummary = "Captures the domain in which the AI package can be used.", _propertyDescription = "Domain describes the domain in which the AI model contained in the AI\nsoftware can be expected to operate successfully. Examples include\ncomputer vision, natural language etc.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","domain")]}),("energyConsumption",Spdx3Property {_propertySummary = "Indicates the amount of energy consumed to build the AI package.", _propertyDescription = "EnergyConsumption captures the amount of energy needed to train and\noperate the AI model. This value is also known as training energy\nconsumption or inference energy consumption.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","energyConsumption")]}),("hyperparameter",Spdx3Property {_propertySummary = "Records a hyperparameter used to build the AI model contained in the AI\npackage.", _propertyDescription = "This field records a hyperparameter value. Hyperparameters are\nparameters of the machine learning model that are used to control the\nlearning process, for example the optimization and learning rate used\nduring the training of the model.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DictionaryEntry"),("name","hyperparameter")]}),("informationAboutApplication",Spdx3Property {_propertySummary = "Provides relevant information about the AI software, not including the\nmodel description.", _propertyDescription = "InformationAboutApplication describes any relevant information in free\nform text about how the AI model is used inside the software, as well as\nany relevant pre-processing steps, third party APIs etc.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","informationAboutApplication")]}),("informationAboutTraining",Spdx3Property {_propertySummary = "Describes relevant information about different steps of the training\nprocess.", _propertyDescription = "InformationAboutTraining describes the specific steps involved in the\ntraining of the AI model. For example, it can be specified whether\nsupervised fine-tuning or active learning is used as part of training\nthe model.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","informationAboutTraining")]}),("limitation",Spdx3Property {_propertySummary = "Captures a limitation of the AI software.", _propertyDescription = "Limitation captures a limitation of the AI Package (or of the AI models\npresent in the AI package), expressed as free form text. Note that this\nis not guaranteed to be exhaustive. For instance, a limitation might be\nthat the AI package cannot be used on datasets from a certain\ndemography.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","limitation")]}),("metric",Spdx3Property {_propertySummary = "Records the measurement of prediction quality of the AI model.", _propertyDescription = "Metric records the measurement with which the AI model was evaluated.\nThis makes statements about the prediction quality including\nuncertainty, accuracy, characteristics of the tested population,\nquality, fairness, explainability, robustness etc.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DictionaryEntry"),("name","metric")]}),("metricDecisionThreshold",Spdx3Property {_propertySummary = "Captures the threshold that was used for computation of a metric\ndescribed in the metric field.", _propertyDescription = "Each metric might be computed based on a decision threshold. For\ninstance, precision or recall is typically computed by checking if the\nprobability of the outcome is larger than 0.5. Each decision threshold\nshould match with a metric field defined in the AI Package.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DictionaryEntry"),("name","metricDecisionThreshold")]}),("modelDataPreprocessing",Spdx3Property {_propertySummary = "Describes all the preprocessing steps applied to the training data\nbefore the model training.", _propertyDescription = "ModelDataPreprocessing is a free form text that describes the\npreprocessing steps applied to the training data before training of the\nmodel(s) contained in the AI software.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","modelDataPreprocessing")]}),("modelExplainability",Spdx3Property {_propertySummary = "Describes methods that can be used to explain the model.", _propertyDescription = "ModelExplainability is a free form text that lists the different\nexplainability mechanisms (such as SHAP, or other model specific\nexplainability mechanisms) that can be used to explain the model.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","modelExplainability")]}),("safetyRiskAssessment",Spdx3Property {_propertySummary = "Categorizes safety risk impact of AI software.", _propertyDescription = "SafetyRiskAssessment categorizes the safety risk impact of the AI\nsoftware in accordance with Article 20 of [EC Regulation No\n765/2008](https://ec.europa.eu/docsroom/documents/17107/attachments/1/translations/en/renditions/pdf).", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SafetyRiskAssessmentType"),("name","safetyRiskAssessment")]}),("sensitivePersonalInformation",Spdx3Property {_propertySummary = "Records if sensitive personal information is used during model training.", _propertyDescription = "SensitivePersonalInformation notes if sensitive personal information is\nused in the training or inference of the AI models. This might include\nbiometric data, addresses or other data that can be used to infer a\nperson's identity.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","PresenceType"),("name","sensitivePersonalInformation")]}),("standardCompliance",Spdx3Property {_propertySummary = "Captures a standard that is being complied with.", _propertyDescription = "StandardCompliance captures a standard that the AI software complies\nwith. This includes both published and unpublished standards, for\nexample ISO, IEEE, ETSI etc. The standard could (but not necessarily\nhave to) be used to satisfy a legal or regulatory requirement.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","standardCompliance")]}),("typeOfModel",Spdx3Property {_propertySummary = "Records the type of the model used in the AI software.", _propertyDescription = "TypeOfModel records the type of the AI model(s) used in the software.\nFor instance, if it is a supervised model, unsupervised model,\nreinforcement learning model or a combination of those.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","typeOfModel")]})], _profileVocabularies = fromList [("PresenceType",Spdx3Vocabulary {_vocabularySummary = "Categories of presence or absence.", _vocabularyDescription = "This type is used to indicate if a given field is present or absent or\nunknown.", _vocabularyMetadata = fromList [("name","PresenceType")], _vocabularyEntries = fromList [("no","Indicates absence of the field."),("noAssertion","Makes no assertion about the field."),("yes","Indicates presence of the field.")]}),("SafetyRiskAssessmentType",Spdx3Vocabulary {_vocabularySummary = "Categories of safety risk impact of the application.", _vocabularyDescription = "Lists the different safety risk type values that can be used to describe\nthe safety risk of AI software according to [Article 20 of Regulation\n765/2008/EC](https://ec.europa.eu/docsroom/documents/17107/attachments/1/translations/en/renditions/pdf).", _vocabularyMetadata = fromList [("name","SafetyRiskAssessmentType")], _vocabularyEntries = fromList [("high","The second-highest level of risk posed by an AI software."),("low","Low/no risk is posed by the AI software."),("medium","The third-highest level of risk posed by an AI software."),("serious","The highest level of risk posed by an AI software.")]})], _profileClasses = fromList [("AIPackage",Spdx3Class {_classSummary = "Provides information about the fields in the AI package profile.", _classDescription = "Metadata information that can be added to a package to describe an AI\napplication or trained AI model.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","/Software/Package"),("name","AIPackage")], _classProperties = fromList [("autonomyType",Spdx3ClassPropertyParameters {_propertyType = "PresenceType", _minCount = Just 0, _maxCount = Just 1}),("domain",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("energyConsumption",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("hyperparameter",Spdx3ClassPropertyParameters {_propertyType = "/Core/DictionaryEntry", _minCount = Just 0, _maxCount = Nothing}),("informationAboutApplication",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("informationAboutTraining",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("limitation",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("metric",Spdx3ClassPropertyParameters {_propertyType = "/Core/DictionaryEntry", _minCount = Just 0, _maxCount = Nothing}),("metricDecisionThreshold",Spdx3ClassPropertyParameters {_propertyType = "/Core/DictionaryEntry", _minCount = Just 0, _maxCount = Nothing}),("modelDataPreprocessing",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("modelExplainability",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("safetyRiskAssessment",Spdx3ClassPropertyParameters {_propertyType = "SafetyRiskAssessmentType", _minCount = Just 0, _maxCount = Just 1}),("sensitivePersonalInformation",Spdx3ClassPropertyParameters {_propertyType = "PresenceType", _minCount = Just 0, _maxCount = Just 1}),("standardCompliance",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("typeOfModel",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing})]})]}),("Build",Spdx3Profile {_profileSummary = "Everything having to do with the build profile.", _profileDescription = "The Build namespace defines concepts related to building of artifacts.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3/Build"),("name","Build")], _profileProperties = fromList [("buildEndTime",Spdx3Property {_propertySummary = "Property that describes the time at which a build stops.", _propertyDescription = "buildEndTime describes the time at which a build stops or finishes. This\nvalue is typically recorded by the builder.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DateTime"),("name","buildEndTime")]}),("buildId",Spdx3Property {_propertySummary = "A buildId is a locally unique identifier used by a builder to identify a\nunique instance of a build produced by it.", _propertyDescription = "A buildId is a locally unique identifier to identify a unique instance\nof a build. This identifier differs based on build toolchain, platform,\nor naming convention used by an organization or standard.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","buildId")]}),("buildStartTime",Spdx3Property {_propertySummary = "Property describing the start time of a build.", _propertyDescription = "buildStartTime is the time at which a build is triggered. The builder\ntypically records this value.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DateTime"),("name","buildStartTime")]}),("buildType",Spdx3Property {_propertySummary = "A buildType is a hint that is used to indicate the toolchain, platform,\nor infrastructure that the build was invoked on.", _propertyDescription = "A buildType is a URI expressing the toolchain, platform, or\ninfrastructure that the build was invoked on. For example, if the build\nwas invoked on GitHub's CI platform using github actions, the buildType\ncan be expressed as `https://github.com/actions`. In contrast, if the\nbuild was invoked on a local machine, the buildType can be expressed as\n`file://username@host/path/to/build`.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","buildType")]}),("configSourceDigest",Spdx3Property {_propertySummary = "Property that describes the digest of the build configuration file used\nto invoke a build.", _propertyDescription = "configSourceDigest is the checksum of the build configuration file used\nby a builder to execute a build. This Property uses the Core model's\n[Hash](../../Core/Classes/Hash.md) class.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/Hash"),("name","configSourceDigest")]}),("configSourceEntrypoint",Spdx3Property {_propertySummary = "Property describes the invocation entrypoint of a build.", _propertyDescription = "A build entrypoint is the invoked executable of a build which always\nruns when the build is triggered. For example, when a build is triggered\nby running a shell script, the entrypoint is `script.sh`. In terms of a\ndeclared build, the entrypoint is the position in a configuration file\nor a build declaration which is always run when the build is triggered.\nFor example, in the following configuration file, the entrypoint of the\nbuild is `publish`.\n\n\\`\\`\\` name: Publish packages to PyPI\n\non: create: tags: \"\\*\"\n\njobs: publish: runs-on: ubuntu-latest if: startsWith(github.ref,\n'refs/tags/') steps:\n\n... \\`\\`\\`", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","configSourceEntrypoint")]}),("configSourceUri",Spdx3Property {_propertySummary = "Property that describes the URI of the build configuration source file.", _propertyDescription = "If a build configuration exists for the toolchain or platform performing\nthe build, the configSourceUri of a build is the URI of that build\nconfiguration. For example, a build triggered by a GitHub action is\ndefined by a build configuration YAML file. In this case, the\nconfigSourceUri is the URL of that YAML file. m", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","configSourceUri")]}),("environment",Spdx3Property {_propertySummary = "Property describing the session in which a build is invoked.", _propertyDescription = "environment is a map of environment variables and values that are set\nduring a build session. This is different from the\n[parameters](parameters.md) property in that it describes the\nenvironment variables set before a build is invoked rather than the\nvariables provided to the builder.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DictionaryEntry"),("name","environment")]}),("parameters",Spdx3Property {_propertySummary = "Property describing the parameters used in an instance of a build.", _propertyDescription = "parameters is a key-value map of all build parameters and their values\nthat were provided to the builder for a build instance. This is\ndifferent from the [environment](environment.md) property in that the\nkeys and values are provided as command line arguments or a\nconfiguration file to the builder.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DictionaryEntry"),("name","parameters")]})], _profileVocabularies = fromList [], _profileClasses = fromList [("Build",Spdx3Class {_classSummary = "Class that describes a build instance of software/artifacts.", _classDescription = "A build is a representation of the process in which a piece of software\nor artifact is built. It encapsulates information related to a build\nprocess and provides an element from which relationships can be created\nto describe the build's inputs, outputs, and related entities (e.g.\nbuilders, identities, etc.).\n\nDefinitions of \"BuildType\", \"ConfigSource\", \"Parameters\" and\n\"Environment\" follow those defined in [SLSA\nprovenance](https://slsa.dev/provenance/v0.2).\n\nExternalIdentifier of type \"urlScheme\" may be used to identify build\nlogs. In this case, the comment of the ExternalIdentifier should be\n\"LogReference\".\n\nNote that buildStart and buildEnd are optional, and may be omitted to\nsimplify creating reproducible builds.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","/Core/Element"),("name","Build")], _classProperties = fromList [("buildEndTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1}),("buildId",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("buildStartTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1}),("buildType",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 1, _maxCount = Just 1}),("configSourceDigest",Spdx3ClassPropertyParameters {_propertyType = "/Core/Hash", _minCount = Just 0, _maxCount = Nothing}),("configSourceEntrypoint",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("configSourceUri",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Nothing}),("environment",Spdx3ClassPropertyParameters {_propertyType = "/Core/DictionaryEntry", _minCount = Just 0, _maxCount = Nothing}),("parameters",Spdx3ClassPropertyParameters {_propertyType = "/Core/DictionaryEntry", _minCount = Just 0, _maxCount = Nothing})]})]}),("Core",Spdx3Profile {_profileSummary = "The basis for all SPDX profiles.", _profileDescription = "The Core namespace defines foundational concepts serving as the basis\nfor all SPDX-3.0 profiles.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3/Core"),("name","Core")], _profileProperties = fromList [("algorithm",Spdx3Property {_propertySummary = "Specifies the algorithm used for calculating the hash value.", _propertyDescription = "An algorithm specifies the algorithm that was used for calculating the\nhash value.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","HashAlgorithm"),("name","algorithm")]}),("annotationType",Spdx3Property {_propertySummary = "Describes the type of annotation.", _propertyDescription = "An annotationType describes the type of an annotation.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","AnnotationType"),("name","annotationType")]}),("begin",Spdx3Property {_propertySummary = "Defines the beginning of a range.", _propertyDescription = "begin is a positive integer that defines the beginning of a range.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:positiveInteger"),("name","begin")]}),("builtTime",Spdx3Property {_propertySummary = "Specifies the time an artifact was built.", _propertyDescription = "A builtTime specifies the time an artifact was built.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DateTime"),("name","builtTime")]}),("comment",Spdx3Property {_propertySummary = "Provide consumers with comments by the creator of the Element about the\nElement.", _propertyDescription = "A comment is an optional field for creators of the Element to provide\ncomments to the readers/reviewers of the document.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","comment")]}),("completeness",Spdx3Property {_propertySummary = "Provides information about the completeness of relationships.", _propertyDescription = "Completeness gives information about whether the provided relationships\nare complete, known to be incomplete or if no assertion is made either\nway.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","RelationshipCompleteness"),("name","completeness")]}),("contentType",Spdx3Property {_propertySummary = "Specifies the media type of an Element.", _propertyDescription = "ContentType specifies the media type of an Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","MediaType"),("name","contentType")]}),("context",Spdx3Property {_propertySummary = "Gives information about the circumstances or unifying properties that\nElements of the bundle have been assembled under.", _propertyDescription = "A context gives information about the circumstances or unifying\nproperties that Elements of the bundle have been assembled under.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","context")]}),("created",Spdx3Property {_propertySummary = "Identifies when the Element was originally created.", _propertyDescription = "Created is a date that identifies when the Element was originally\ncreated. The time stamp can serve as an indication as to whether the\nanalysis needs to be updated. This is often the date of last change\n(e.g., a git commit date), not the date when the SPDX data was created,\nas doing so supports reproducible builds.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DateTime"),("name","created")]}),("createdBy",Spdx3Property {_propertySummary = "Identifies who or what created the Element.", _propertyDescription = "CreatedBy identifies who or what created the Element. The generation\nmethod will assist the recipient of the Element in assessing the general\nreliability/accuracy of the analysis information.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Agent"),("name","createdBy")]}),("createdUsing",Spdx3Property {_propertySummary = "Identifies the tooling that was used during the creation of the Element.", _propertyDescription = "CreatedUsing identifies the tooling that was used during the creation of\nthe Element. The generation method will assist the recipient of the\nElement in assessing the general reliability/accuracy of the analysis\ninformation.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Tool"),("name","createdUsing")]}),("creationInfo",Spdx3Property {_propertySummary = "Provides information about the creation of the Element.", _propertyDescription = "CreationInfo provides information about the creation of the Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","CreationInfo"),("name","creationInfo")]}),("dataLicense",Spdx3Property {_propertySummary = "Provides the license under which the SPDX documentation of the Element\ncan be used.", _propertyDescription = "The data license provides the license under which the SPDX documentation\nof the Element can be used. This is to alleviate any concern that\ncontent (the data or database) in an SPDX file is subject to any form of\nintellectual property right that could restrict the re-use of the\ninformation or the creation of another SPDX file for the same\nproject(s). This approach avoids intellectual property and related\nrestrictions over the SPDX file, however individuals can still contract\nwith each other to restrict release of specific collections of SPDX\nfiles (which map to software bill of materials) and the identification\nof the supplier of SPDX files. Compliance with this document includes\npopulating the SPDX fields therein with data related to such fields\n(\"SPDX-Metadata\"). This document contains numerous fields where an SPDX\nfile creator may provide relevant explanatory text in SPDX-Metadata.\nWithout opining on the lawfulness of \"database rights\" (in jurisdictions\nwhere applicable), such explanatory text is copyrightable subject matter\nin most Berne Convention countries. By using the SPDX specification, or\nany portion hereof, you hereby agree that any copyright rights (as\ndetermined by your jurisdiction) in any SPDX-Metadata, including without\nlimitation explanatory text, shall be subject to the terms of the\nCreative Commons CC0 1.0 Universal license. For SPDX-Metadata not\ncontaining any copyright rights, you hereby agree and acknowledge that\nthe SPDX-Metadata is provided to you \8220as-is\8221 and without any\nrepresentations or warranties of any kind concerning the SPDX-Metadata,\nexpress, implied, statutory or otherwise, including without limitation\nwarranties of title, merchantability, fitness for a particular purpose,\nnon-infringement, or the absence of latent or other defects, accuracy,\nor the presence or absence of errors, whether or not discoverable, all\nto the greatest extent permissible under applicable law.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","dataLicense")]}),("definingDocument",Spdx3Property {_propertySummary = "URI for an SPDX document which defines an SPDX element.", _propertyDescription = "A definingDocument property is used to link an Element identifier to an\nSpdxDocument which contains the definition for the Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","definingDocument")]}),("description",Spdx3Property {_propertySummary = "Provides a detailed description of the Element.", _propertyDescription = "This field is a detailed description of the Element. It may also be\nextracted from the Element itself. The intent is to provide recipients\nof the SPDX file with a detailed technical explanation of the\nfunctionality, anticipated use, and anticipated implementation of the\nElement. This field may also include a description of improvements over\nprior versions of the Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","description")]}),("element",Spdx3Property {_propertySummary = "Refers to one or more Elements that are part of an ElementCollection.", _propertyDescription = "This field refers to one or more Elements that are part of an\nElementCollection.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","element")]}),("end",Spdx3Property {_propertySummary = "Defines the end of a range.", _propertyDescription = "end is a positive integer that defines the end of a range.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:positiveInteger"),("name","end")]}),("endTime",Spdx3Property {_propertySummary = "Specifies the time from which an element is no longer applicable /\nvalid.", _propertyDescription = "A endTime specifies the time from which element is no applicable /\nvalid.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DateTime"),("name","endTime")]}),("extension",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "TODO", _propertyMetadata = fromList [("name","extension")]}),("externalId",Spdx3Property {_propertySummary = "Identifies an external Element used within a Document but defined\nexternal to that Document.", _propertyDescription = "ExternalId identifies an external Element used within a Document but\ndefined external to that Document.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","externalId")]}),("externalIdentifier",Spdx3Property {_propertySummary = "Provides a reference to a resource outside the scope of SPDX-3.0 content\nthat uniquely identifies an Element.", _propertyDescription = "ExternalIdentifier points to a resource outside the scope of SPDX-3.0\ncontent that uniquely identifies an Element.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","ExternalIdentifier"),("name","externalIdentifier")]}),("externalIdentifierType",Spdx3Property {_propertySummary = "Specifies the type of the external identifier.", _propertyDescription = "An externalIdentifierType specifies the type of the external identifier.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ExternalIdentifierType"),("name","externalIdentifierType")]}),("externalReference",Spdx3Property {_propertySummary = "Points to a resource outside the scope of the SPDX-3.0 content that\nprovides additional characteristics of an Element.", _propertyDescription = "This field points to a resource outside the scope of the SPDX-3.0\ncontent that provides additional characteristics of an Element.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","ExternalReference"),("name","externalReference")]}),("externalReferenceType",Spdx3Property {_propertySummary = "Specifies the type of the external reference.", _propertyDescription = "An externalReferenceType specifies the type of the external reference.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ExternalReferenceType"),("name","externalReferenceType")]}),("from",Spdx3Property {_propertySummary = "References the Element on the left-hand side of a relationship.", _propertyDescription = "This field references the Element on the left-hand side of a\nrelationship.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","from")]}),("hashValue",Spdx3Property {_propertySummary = "The result of applying a hash algorithm to an Element.", _propertyDescription = "HashValue is the result of applying a hash algorithm to an Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","hashValue")]}),("identifier",Spdx3Property {_propertySummary = "Uniquely identifies an external element.", _propertyDescription = "An identifier uniquely identifies an external element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","identifier")]}),("identifierLocator",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A identifierLocator is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","identifierLocator")]}),("imports",Spdx3Property {_propertySummary = "Provides an ExternalMap of Element identifiers.", _propertyDescription = "Imports provides an ExternalMap of Element identifiers that are used\nwithin a document but defined external to that document.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ExternalMap"),("name","imports")]}),("issuingAuthority",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A issuingAuthority is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","issuingAuthority")]}),("key",Spdx3Property {_propertySummary = "A key used in a generic key-value pair.", _propertyDescription = "A key used in generic a key-value pair. A key-value pair can be used to\nimplement a dictionary which associates a key with a value.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","key")]}),("locationHint",Spdx3Property {_propertySummary = "Provides an indication of where to retrieve an external Element.", _propertyDescription = "A locationHint provides an indication of where to retrieve an external\nElement.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","locationHint")]}),("locator",Spdx3Property {_propertySummary = "Provides the location of an external reference.", _propertyDescription = "A locator provides the location of an external reference.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","locator")]}),("name",Spdx3Property {_propertySummary = "Identifies the name of an Element as designated by the creator.", _propertyDescription = "This field identifies the name of an Element as designated by the\ncreator. The name of an Element is an important convention and easier to\nrefer to than the URI.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","name")]}),("namespace",Spdx3Property {_propertySummary = "Provides an unambiguous mechanism for other documents to reference\nElements within this document.", _propertyDescription = "A namespace provides an unambiguous mechanism for other documents to\nreference Elements within this document.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","namespace")]}),("namespaces",Spdx3Property {_propertySummary = "Provides a NamespaceMap applicable to an ElementCollection.", _propertyDescription = "This field provides a NamespaceMap applicable to an ElementCollection.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","NamespaceMap"),("name","namespaces")]}),("originatedBy",Spdx3Property {_propertySummary = "Identifies from where or whom the Element originally came.", _propertyDescription = "OriginatedBy identifies from where or whom the Element originally came.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Agent"),("name","originatedBy")]}),("prefix",Spdx3Property {_propertySummary = "A substitute for a URI.", _propertyDescription = "A prefix is a substitute for a URI.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","prefix")]}),("profile",Spdx3Property {_propertySummary = "Provides information about which profiles the Element belongs to.", _propertyDescription = "This field provides information about which profiles the Element belongs\nto.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ProfileIdentifierType"),("name","profile")]}),("relationshipType",Spdx3Property {_propertySummary = "Information about the relationship between two Elements.", _propertyDescription = "This field provides information about the relationship between two\nElements. For example, you can represent a relationship between two\ndifferent Files, between a Package and a File, between two Packages, or\nbetween one SPDXDocument and another SPDXDocument.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","RelationshipType"),("name","relationshipType")]}),("releaseTime",Spdx3Property {_propertySummary = "Specifies the time an artifact was released.", _propertyDescription = "A releaseTime specifies the time an artifact was released.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DateTime"),("name","releaseTime")]}),("rootElement",Spdx3Property {_propertySummary = "Top level Element from which all other Elements are reached via\nrelationships.", _propertyDescription = "A rootElement of a collection is the top level Element from which all\nother Elements are reached via relationships.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","rootElement")]}),("scope",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A scope is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","LifecycleScopeType"),("name","scope")]}),("spdxId",Spdx3Property {_propertySummary = "Identifies an Element to be referenced by other Elements.", _propertyDescription = "SpdxId uniquely identifies an Element which may thereby be referenced by\nother Elements. These references may be internal or external. While\nthere may be several versions of the same Element, each one needs to be\nable to be referred to uniquely so that relationships between Elements\ncan be clearly articulated.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","spdxId")]}),("specVersion",Spdx3Property {_propertySummary = "Provides a reference number that can be used to understand how to parse\nand interpret an Element.", _propertyDescription = "The specVersion provides a reference number that can be used to\nunderstand how to parse and interpret an Element. It will enable both\nfuture changes to the specification and to support backward\ncompatibility. The major version number shall be incremented when\nincompatible changes between versions are made (one or more sections are\ncreated, modified or deleted). The minor version number shall be\nincremented when backwards compatible changes are made.\n\nHere, parties exchanging information in accordance with the SPDX\nspecification need to provide 100% transparency as to which SPDX\nspecification version such information is conforming to.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SemVer"),("name","specVersion")]}),("standard",Spdx3Property {_propertySummary = "The relevant standards that may apply to an artifact.", _propertyDescription = "Various standards may be relevant to useful to capture for specific\nartifacts.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","standard")]}),("startTime",Spdx3Property {_propertySummary = "Specifies the time from which an element is applicable / valid.", _propertyDescription = "A startTime specifies the time from which element is applicable / valid.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DateTime"),("name","startTime")]}),("statement",Spdx3Property {_propertySummary = "Commentary on an assertion that an annotator has made.", _propertyDescription = "A statement is a commentary on an assertion that an annotator has made.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","statement")]}),("subject",Spdx3Property {_propertySummary = "An Element an annotator has made an assertion about.", _propertyDescription = "A subject is an Element an annotator has made an assertion about.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","subject")]}),("summary",Spdx3Property {_propertySummary = "A short description of an Element.", _propertyDescription = "A summary is a short description of an Element. Here, the intent is to\nallow the Element creator to provide concise information about the\nfunction or use of the Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","summary")]}),("suppliedBy",Spdx3Property {_propertySummary = "Identifies who or what supplied the Artifact.", _propertyDescription = "Identify the actual distribution source for the Artifact being\nreferenced. This might or might not be different from the originating\ndistribution source for the artifact.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Agent"),("name","suppliedBy")]}),("to",Spdx3Property {_propertySummary = "References an Element on the right-hand side of a relationship.", _propertyDescription = "This field references an Element on the right-hand side of a\nrelationship.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","to")]}),("validUntilTime",Spdx3Property {_propertySummary = "Specifies until when the artifact can be used before its usage needs to\nbe reassessed.", _propertyDescription = "A validUntilTime specifies until when the artifact can be used before\nits usage needs to be reassessed.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DateTime"),("name","validUntilTime")]}),("value",Spdx3Property {_propertySummary = "A value used in a generic key-value pair.", _propertyDescription = "A value used in a generic key-value pair. A key-value pair can be used\nto implement a dictionary which associates a key with a value.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","value")]}),("verifiedUsing",Spdx3Property {_propertySummary = "Provides an IntegrityMethod with which the integrity of an Element can\nbe asserted.", _propertyDescription = "VerifiedUsing provides an IntegrityMethod with which the integrity of an\nElement can be asserted.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","IntegrityMethod"),("name","verifiedUsing")]})], _profileVocabularies = fromList [("AnnotationType",Spdx3Vocabulary {_vocabularySummary = "Specifies the type of an annotation.", _vocabularyDescription = "AnnotationType specifies the type of an annotation.", _vocabularyMetadata = fromList [("name","AnnotationType")], _vocabularyEntries = fromList [("other","Used to store extra information about an Element which is not part of a\nReview (e.g. extra information provided during the creation of the\nElement)."),("review","Used when someone reviews the Element.")]}),("ExternalIdentifierType",Spdx3Vocabulary {_vocabularySummary = "Specifies the type of an external identifier.", _vocabularyDescription = "ExteralIdentifierType specifies the type of an external identifier.", _vocabularyMetadata = fromList [("name","ExternalIdentifierType")], _vocabularyEntries = fromList [("cpe22","https://cpe.mitre.org/files/cpe-specification\\_2.2.pdf"),("cpe23","https://nvlpubs.nist.gov/nistpubs/Legacy/IR/nistir7695.pdf"),("cve","An identifier for a specific software flaw defined within the official\nCVE Dictionary and that conforms to the CVE specification as defined by\nhttps://csrc.nist.gov/glossary/term/cve\\_id."),("email","https://datatracker.ietf.org/doc/html/rfc3696#section-3"),("gitoid","gitoid stands for Git Object ID. A gitoid of typeblob is a unique hash\nof a software artifact. Git relies on a Merkle Tree to index stored\nobjects. See https://git-scm.com/book/en/v2/Git-Internals-Git-Objects.\nGitBOM is an amalgam of the terms \"Git\" and \"SBOM\". GitBOM is a\nminimalistic schema to describe software dependency graphs using a\nMerkle Tree, and is inspired by Git. A gitoid may refer to either the\nsoftware artifact or its GitBOM document; this ambiguity exists because\nthe GitBOM document is itself an artifact, and the gitoid of that\nartifact is its valid locator."),("other","Used when the type doesn't match any of the other options."),("pkgUrl","https://github.com/package-url/purl-spec"),("securityOther","Used when there is a security related identifier of unspecified type."),("swhid","https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html"),("swid","https://www.ietf.org/archive/id/draft-ietf-sacm-coswid-21.html#section-2.3"),("urlScheme","the scheme used in order to locate a resource\nhttps://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml")]}),("ExternalReferenceType",Spdx3Vocabulary {_vocabularySummary = "Specifies the type of an external reference.", _vocabularyDescription = "ExteralReferenceType specifies the type of an external reference.", _vocabularyMetadata = fromList [("name","ExternalReferenceType")], _vocabularyEntries = fromList [("altDownloadLocation","A reference to an alternative download location."),("altWebPage","A reference to an alternative web page."),("binaryArtifact","A reference to binary artifacts related to a package."),("buildMeta","A reference build metadata related to a published package."),("buildSystem","A reference build system used to create or publish the package."),("certificationReport","A reference to a certification report for a package from an\naccredited/independent body."),("chat","A reference to the instant messaging system used by the maintainer for a\npackage."),("componentAnalysisReport","A reference to a Software Composition Analysis (SCA) report."),("documentation","A reference to the documentation for a package."),("dynamicAnalysisReport","A reference to a dynamic analysis report for a package."),("eolNotice","A reference to the End Of Sale (EOS) and/or End Of Life (EOL)\ninformation related to a package."),("funding","A reference to funding information related to a package."),("issueTracker","A reference to the issue tracker for a package."),("license","A reference to additional license information related to an artifact."),("mailingList","A reference to the mailing list used by the maintainer for a package."),("metrics","A reference to metrics related to package such as OpenSSF scorecards."),("other","Used when the type doesn't match any of the other options."),("productMetadata","A reference to additional product metadata such as reference within\norganization's product catalog."),("qualityAssessmentReport","A reference to a quality assessment for a package."),("releaseHistory","A reference to a published list of releases for a package."),("releaseNotes","A reference to the release notes for a package."),("riskAssessment","A reference to a risk assessment for a package."),("runtimeAnalysisReport","A reference to a runtime analysis report for a package."),("secureSoftwareAttestation","A reference to information assuring that the software is developed using\nsecurity practices as defined by [NIST SP 800-218 Secure Software\nDevelopment Framework\n(SSDF)](https://csrc.nist.gov/publications/detail/sp/800-218/final) or\n[CISA Secure Software Development Attestation\nForm](https://www.cisa.gov/sites/default/files/2023-04/secure-software-self-attestation_common-form_508.pdf)."),("securityAdversaryModel","A reference to the security adversary model for a package."),("securityAdvisory","A reference to a published security advisory (where advisory as defined\nper ISO 29147:2018) that may affect one or more elements, e.g., vendor\nadvisories or specific NVD entries."),("securityFix","A reference to the patch or source code that fixes a vulnerability."),("securityOther","A reference to related security information of unspecified type."),("securityPenTestReport","A reference to a [penetration\ntest](https://en.wikipedia.org/wiki/Penetration_test) report for a\npackage."),("securityPolicy","A reference to instructions for reporting newly discovered security\nvulnerabilities for a package."),("securityThreatModel","A reference the [security threat\nmodel](https://en.wikipedia.org/wiki/Threat_model) for a package."),("socialMedia","A reference to a social media channel for a package."),("sourceArtifact","A reference to an artifact containing the sources for a package."),("staticAnalysisReport","A reference to a static analysis report for a package."),("support","A reference to the software support channel or other support information\nfor a package."),("vcs","A reference to a version control system related to a software artifact."),("vulnerabilityDisclosureReport","A reference to a Vulnerability Disclosure Report (VDR) which provides\nthe software supplier's analysis and findings describing the impact (or\nlack of impact) that reported vulnerabilities have on packages or\nproducts in the supplier's SBOM as defined in [NIST SP\n800-161](https://csrc.nist.gov/publications/detail/sp/800-161/rev-1/final)."),("vulnerabilityExploitabilityAssessment","A reference to a Vulnerability Exploitability eXchange (VEX) statement\nwhich provides information on whether a product is impacted by a\nspecific vulnerability in an included package and, if affected, whether\nthere are actions recommended to remediate. See also [NTIA VEX\none-page](https://ntia.gov/files/ntia/publications/vex_one-page_summary.pdf)..")]}),("HashAlgorithm",Spdx3Vocabulary {_vocabularySummary = "A mathematical algorithm that maps data of arbitrary size to a bit\nstring.", _vocabularyDescription = "A HashAlgorithm is a mathematical algorithm that maps data of arbitrary\nsize to a bit string (the hash) and is a one-way function, that is, a\nfunction which is practically infeasible to invert.", _vocabularyMetadata = fromList [("name","HashAlgorithm")], _vocabularyEntries = fromList [("blake2b256","blake2b algorithm with a digest size of 256\nhttps://datatracker.ietf.org/doc/html/rfc7693#section-4"),("blake2b384","blake2b algorithm with a digest size of 384\nhttps://datatracker.ietf.org/doc/html/rfc7693#section-4"),("blake2b512","blake2b algorithm with a digest size of 512\nhttps://datatracker.ietf.org/doc/html/rfc7693#section-4"),("blake3","https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf"),("crystalsDilithium","https://pq-crystals.org/dilithium/index.shtml"),("crystalsKyber","https://pq-crystals.org/kyber/index.shtml"),("falcon","https://falcon-sign.info/falcon.pdf"),("md2","https://datatracker.ietf.org/doc/rfc1319/"),("md4","https://datatracker.ietf.org/doc/html/rfc1186"),("md5","https://datatracker.ietf.org/doc/html/rfc1321"),("md6","https://people.csail.mit.edu/rivest/pubs/RABCx08.pdf"),("other","any hashing algorithm that does not exist in this list of entries"),("sha1","https://datatracker.ietf.org/doc/html/rfc3174"),("sha224","secure hashing algorithm with a digest length of 224\nhttps://datatracker.ietf.org/doc/html/draft-ietf-pkix-sha224-01"),("sha256","secure hashing algorithm with a digest length of 256\nhttps://www.rfc-editor.org/rfc/rfc4634"),("sha384","secure hashing algorithm with a digest length of 384\nhttps://www.rfc-editor.org/rfc/rfc4634"),("sha3_224","sha3 with a digest length of 224\nhttps://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf"),("sha3_256","sha3 with a digest length of 256\nhttps://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf"),("sha3_384","sha3 with a digest length of 384\nhttps://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf"),("sha3_512","sha3 with a digest length of 512\nhttps://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf"),("sha512","secure hashing algorithm with a digest length of 512\nhttps://www.rfc-editor.org/rfc/rfc4634"),("spdxPvcSha1","TODOdescription"),("spdxPvcSha256","TODOdescription"),("sphincsPlus","TODOdescription")]}),("LifecycleScopeType",Spdx3Vocabulary {_vocabularySummary = "TODO", _vocabularyDescription = "TODO", _vocabularyMetadata = fromList [("name","LifecycleScopeType")], _vocabularyEntries = fromList [("build","TODOdescription"),("design","TODOdescription"),("development","TODOdescription"),("other","TODOdescription"),("runtime","TODOdescription"),("test","TODOdescription")]}),("ProfileIdentifierType",Spdx3Vocabulary {_vocabularySummary = "Enumeration of the valid profiles that an element can be specified to be\npart of.", _vocabularyDescription = "There are a set of profiles that have been defined to be valid for a\nspecific release This file enumerates the values that have been agreed\non, and may be applied to the creation information for an an element.", _vocabularyMetadata = fromList [("name","ProfileIdentifierType")], _vocabularyEntries = fromList [("ai","the element follows the AI profile specification"),("build","the element follows the Build profile specification"),("core","the element follows the Core profile specification"),("dataset","the element follows the Dataset profile specification"),("extension","the element follows the Extension profile specification"),("licensing","the element follows the Licensing profile specification"),("security","the element follows the Security profile specification"),("software","the element follows the Software profile specification"),("usage","the element follows the Usage profile specification")]}),("RelationshipCompleteness",Spdx3Vocabulary {_vocabularySummary = "Indicates whether a relationship is complete or known to be incomplete\nor if there is made no assertion either way.", _vocabularyDescription = "RelationshipCompleteness indicates whether a relationship is complete or\nknown to be incomplete or if there is made no assertion either way.", _vocabularyMetadata = fromList [("name","RelationshipCompleteness")], _vocabularyEntries = fromList [("complete","The relationship is known to be exhaustive."),("incomplete","The relationship is known not to be exhaustive."),("noAssertion","There can be made no assertion about the completeness of the\nrelationship.")]}),("RelationshipType",Spdx3Vocabulary {_vocabularySummary = "Information about the relationship between two Elements.", _vocabularyDescription = "Provides information about the relationship between two Elements. For\nexample, you can represent a relationship between two different Files,\nbetween a Package and a File, between two Packages, or between one\nSPDXDocument and another SPDXDocument.\n\nBuild Profile specific RelationshipType descriptions can be found\n[here](https://github.com/spdx/spdx-3-build-profile/blob/main/model/relationships.md)", _vocabularyMetadata = fromList [("name","RelationshipType")], _vocabularyEntries = fromList [("affects","(Security/VEX) Designates one or more elements as affected by a\nvulnerability"),("amends","Every `to` Element amends the `from` Element"),("ancestor","Every `to` Element is an ancestor of the `from` Element"),("availableFrom","This relationship is used to identify additional suppliers where an\nartifact is available from."),("buildConfigOf","Build configuration of the build instance"),("buildDependency","Every `to` Element is a build dependency of the `from` Element"),("buildHostOf","Element in which the build instance runs on"),("buildInputOf","Input to the build instance"),("buildInvokedBy","Agent that invoked the build"),("buildOnBehalfOf","Actor for which buildInvokedBy is acting on behalf of"),("buildOutputOf","Output of the build instance"),("buildTool","Build tool used to build an Element. This may be used to describe the\nbuild tool of a Build instance"),("contains","Every `to` Element is contained by the `from` Element"),("coordinatedBy","(Security) Used to identify the vendor, researcher, or consumer agent\nperforming coordination for a vulnerability"),("copy","Every `to` Element is a copy of the `from` Element"),("dataFile","Every `to` Element is a data file related to the the `from` Element"),("dependencyManifest","Every `to` Element is manifest file containing dependency information\nrelated to the `from` Element"),("dependsOn","Every `to` Element is a dependecy of the `from` Element"),("descendant","This relationship may be used to describe child builds of a Build\ninstance."),("describes","Every `to` Element is described by the `from` Element. This can be used\nto denote the root(s) of a tree of elements contained in an SBOM."),("devDependency","Every `to` Element is a development dependency for the `from` Element"),("devTool","Every `to` Element is a development tool for the `from` Element"),("distributionArtifact","Every `to` Element is an artifact intended for distribution of the\n`from` Element (e.g. an RPM or archive file)"),("documentation","Every `to` Element is documentation for the `from` Element"),("doesNotAffect","(Security/VEX) Specifies a vulnerability has no impact on one or more\nelements"),("dynamicLink","Every `to` Element is dynamically linked to the `from` Element"),("evidenceFor","(Dataset) Every `to` Element is can be considered as evidence for the\n`from` Element"),("example","Every `to` Element is an example for the `from` Element"),("expandedFromArchive","Every `to` Element is an artifact expanded from the `from` archive file"),("exploitCreatedBy","(Security) Designates an agent has created an exploit against a\nvulnerability"),("fileAdded","Every `to` Element is is a file added to the `from` Element"),("fileDeleted","Every `to` Element is a file deleted from the `from` Element"),("fileModified","Every `to` Element is a modification of the `from` Element"),("fixedBy","(Security) Designates a vulnerability has been fixed by an agent"),("fixedIn","(Security/VEX) A vulnerability has been fixed in one or more elements"),("foundBy","(Security) Designates an agent was the original discoverer of a security\nvulnerability"),("generates","Every `to` Element is generated from the `from` Element"),("hasAssessmentFor","(Security) Relates a Vulnerability and an Element with a security\nassessment."),("hasAssociatedVulnerability","(Security) Used to associate a security vulnerability with a software\nartifact"),("metafile","Every `to` Element is is a file containing metadata about the `from`\nElement"),("optionalComponent","Every `to` Element is an optional component of the `from` Element"),("optionalDependency","Every `to` Element is an optional dependency of the `from` Element"),("other","Every `to` Element is related to the `from` Element where the\nrelationship type is not described by any of the SPDX relationhip types"),("packages","Every `to` Element is a packaged form of the `from` Element"),("patch","Every `to` Element is a patch for the `from` Element"),("prerequisite","Every `to` Element is a prerequisite of the `from` Element"),("providedDependency","Every `to` Element is a dependency not included in the distributed\nartifact but is assumed to be provided the `from` Element"),("publishedBy","(Security) Designates the agent that made a vulnerability record\navailable for public use or reference"),("reportedBy","(Security) Designates the agent that first reported a vulnerability to\nthe project, vendor, or tracking database for formal identification"),("republishedBy","(Security) Designates the agent that tracked, aggregated, and/or\nenriched vulnerability details to improve context (i.e. NVD)"),("requirementFor","Every `to` Element is required for the `from` Element"),("runtimeDependency","Every `to` Element is a runtime dependency for the `from` Element"),("specificationFor","Every `to` Element is a specification for the `from` Element"),("staticLink","Every `to` Element is statically linked to the `from` Element"),("test","Every `to` Element is a test artifact for the `from` Element"),("testCase","Every `to` Element is a test case for the `from` Element"),("testDependency","Every `to` Element is a test dependency for the `from` Element"),("testTool","Every `to` Element is a test tool for the `from` Element"),("testedOn","(AI, Dataset) The `from` Element has been tested on the `to` Element"),("trainedOn","(AI, Dataset) The `from` Element has been trained by the `to` Element(s)"),("underInvestigationFor","(Security/VEX) The impact of a vulnerability is being investigated"),("variant","Every `to` Element is a variant the `from` Element")]})], _profileClasses = fromList [("Agent",Spdx3Class {_classSummary = "Agent represents anything with the potential to act on a system.", _classDescription = "The Agent class represents anything that has the potential to act on a\nsystem. This could be a person, organization, software agent, etc. This\nis not to be confused with tools that are used to perform tasks.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Element"),("name","Agent")], _classProperties = fromList []}),("Annotation",Spdx3Class {_classSummary = "An assertion made in relation to one or more elements.", _classDescription = "An Annotation is an assertion made in relation to one or more elements.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Element"),("name","Annotation")], _classProperties = fromList [("annotationType",Spdx3ClassPropertyParameters {_propertyType = "AnnotationType", _minCount = Just 1, _maxCount = Just 1}),("contentType",Spdx3ClassPropertyParameters {_propertyType = "MediaType", _minCount = Nothing, _maxCount = Nothing}),("statement",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("subject",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Just 1})]}),("AnonymousPayload",Spdx3Class {_classSummary = "TODO", _classDescription = "TODO", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Payload"),("name","AnonymousPayload")], _classProperties = fromList [("creationInfo",Spdx3ClassPropertyParameters {_propertyType = "CreationInfo", _minCount = Just 0, _maxCount = Just 1}),("imports",Spdx3ClassPropertyParameters {_propertyType = "ExternalMap", _minCount = Nothing, _maxCount = Nothing}),("namespaces",Spdx3ClassPropertyParameters {_propertyType = "NamespaceMap", _minCount = Nothing, _maxCount = Nothing})]}),("Artifact",Spdx3Class {_classSummary = "A distinct article or unit within the digital domain.", _classDescription = "An artifact is a distinct article or unit within the digital domain,\nsuch as an electronic file, a software package, a device or an element\nof data.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","Element"),("name","Artifact")], _classProperties = fromList [("builtTime",Spdx3ClassPropertyParameters {_propertyType = "DateTime", _minCount = Just 0, _maxCount = Just 1}),("originatedBy",Spdx3ClassPropertyParameters {_propertyType = "Agent", _minCount = Just 0, _maxCount = Nothing}),("releaseTime",Spdx3ClassPropertyParameters {_propertyType = "DateTime", _minCount = Just 0, _maxCount = Just 1}),("standard",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("suppliedBy",Spdx3ClassPropertyParameters {_propertyType = "Agent", _minCount = Just 0, _maxCount = Nothing}),("validUntilTime",Spdx3ClassPropertyParameters {_propertyType = "DateTime", _minCount = Just 0, _maxCount = Just 1})]}),("Bom",Spdx3Class {_classSummary = "A container for a grouping of SPDX-3.0 content characterizing details\n(provenence, composition, licensing, etc.) about a product.", _classDescription = "A Bill Of Materials (BOM) is a container for a grouping of SPDX-3.0\ncontent characterizing details about a product. This could include\ndetails of the content and composition of the product, provenence\ndetails of the product and/or its composition, licensing information,\nknown quality or security issues, etc.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Bundle"),("name","Bom")], _classProperties = fromList []}),("Bundle",Spdx3Class {_classSummary = "A collection of Elements that have a shared context.", _classDescription = "A bundle is a collection of Elements that have a shared context.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","ElementCollection"),("name","Bundle")], _classProperties = fromList [("context",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1})]}),("CreationInfo",Spdx3Class {_classSummary = "Provides information about the creation of the Element.", _classDescription = "The CreationInfo provides information about who created the Element, and\nwhen and how it was created.\n\nThe dateTime created is often the date of last change (e.g., a git\ncommit date), not the date when the SPDX data was created, as doing so\nsupports reproducible builds.", _classMetadata = fromList [("Instantiability","Concrete"),("name","CreationInfo")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("created",Spdx3ClassPropertyParameters {_propertyType = "DateTime", _minCount = Nothing, _maxCount = Nothing}),("createdBy",Spdx3ClassPropertyParameters {_propertyType = "Agent", _minCount = Just 1, _maxCount = Nothing}),("createdUsing",Spdx3ClassPropertyParameters {_propertyType = "Tool", _minCount = Just 0, _maxCount = Nothing}),("dataLicense",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Nothing}),("profile",Spdx3ClassPropertyParameters {_propertyType = "ProfileIdentifierType", _minCount = Just 1, _maxCount = Nothing}),("specVersion",Spdx3ClassPropertyParameters {_propertyType = "SemVer", _minCount = Nothing, _maxCount = Nothing})]}),("DateTime",Spdx3Class {_classSummary = "A string representing a specific date and time.", _classDescription = "A Datetime is a string representation of a specific date and time. It\nhas resolution of seconds and is always expressed in UTC timezone. The\nspecific format is one of the most commonly used ISO-8601 formats.", _classMetadata = fromList [("SubclassOf","xsd:string"),("name","DateTime")], _classProperties = fromList []}),("DictionaryEntry",Spdx3Class {_classSummary = "A key with an associated value.", _classDescription = "The class used for implementing a generic string mapping (also known as\nassociative array, dictionary, or hash map) in SPDX. Each\nDictionaryEntry contains a key-value pair which maps the key to its\nassociated value. To implement a dictionary, this class is to be used in\na collection with unique keys.", _classMetadata = fromList [("Instantiability","Concrete"),("name","DictionaryEntry")], _classProperties = fromList [("key",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("value",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1})]}),("Element",Spdx3Class {_classSummary = "Base domain class from which all other SPDX-3.0 domain classes derive.", _classDescription = "An Element is a representation of a fundamental concept either directly\ninherent to the Bill of Materials (BOM) domain or indirectly related to\nthe BOM domain and necessary for contextually characterizing BOM\nconcepts and relationships. Within SPDX-3.0 structure this is the base\nclass acting as a consistent, unifying, and interoperable foundation for\nall explicit and inter-relatable content objects.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","Payload"),("name","Element")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("creationInfo",Spdx3ClassPropertyParameters {_propertyType = "CreationInfo", _minCount = Just 0, _maxCount = Just 1}),("description",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("extension",Spdx3ClassPropertyParameters {_propertyType = "Extension", _minCount = Just 0, _maxCount = Nothing}),("externalIdentifier",Spdx3ClassPropertyParameters {_propertyType = "ExternalIdentifier", _minCount = Just 0, _maxCount = Nothing}),("externalReference",Spdx3ClassPropertyParameters {_propertyType = "ExternalReference", _minCount = Just 0, _maxCount = Nothing}),("name",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("spdxId",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 1, _maxCount = Just 1}),("summary",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("verifiedUsing",Spdx3ClassPropertyParameters {_propertyType = "IntegrityMethod", _minCount = Nothing, _maxCount = Nothing})]}),("ElementCollection",Spdx3Class {_classSummary = "A collection of Elements, not necessarily with unifying context.", _classDescription = "An SpdxCollection is a collection of Elements, not necessarily with\nunifying context.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","Element"),("name","ElementCollection")], _classProperties = fromList [("element",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Nothing}),("imports",Spdx3ClassPropertyParameters {_propertyType = "ExternalMap", _minCount = Nothing, _maxCount = Nothing}),("namespaces",Spdx3ClassPropertyParameters {_propertyType = "NamespaceMap", _minCount = Nothing, _maxCount = Nothing}),("rootElement",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Nothing})]}),("ExternalIdentifier",Spdx3Class {_classSummary = "A reference to a resource outside the scope of SPDX-3.0 content that\nuniquely identifies an Element.", _classDescription = "An ExternalIdentifier is a reference to a resource outside the scope of\nSPDX-3.0 content that uniquely identifies an Element.", _classMetadata = fromList [("Instantiability","Concrete"),("name","ExternalIdentifier")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("externalIdentifierType",Spdx3ClassPropertyParameters {_propertyType = "ExternalIdentifierType", _minCount = Just 1, _maxCount = Just 1}),("identifier",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("identifierLocator",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Nothing}),("issuingAuthority",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Just 1})]}),("ExternalMap",Spdx3Class {_classSummary = "A map of Element identifiers that are used within a Document but defined\nexternal to that Document.", _classDescription = "An External Map is a map of Element identifiers that are used within a\nDocument but defined external to that Document. The external map\nprovides details about the externally-defined Element such as its\nprovenance, where to retrieve it, and how to verify its integrity.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","none"),("name","ExternalMap")], _classProperties = fromList [("definingDocument",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Nothing, _maxCount = Just 1}),("externalId",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 1, _maxCount = Just 1}),("locationHint",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Nothing, _maxCount = Just 1}),("verifiedUsing",Spdx3ClassPropertyParameters {_propertyType = "IntegrityMethod", _minCount = Nothing, _maxCount = Nothing})]}),("ExternalReference",Spdx3Class {_classSummary = "A reference to a resource outside the scope of SPDX-3.0 content.", _classDescription = "An External Reference points to a resource outside the scope of the\nSPDX-3.0 content that provides additional characteristics of an Element.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","none"),("name","ExternalReference")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("contentType",Spdx3ClassPropertyParameters {_propertyType = "MediaType", _minCount = Nothing, _maxCount = Just 1}),("externalReferenceType",Spdx3ClassPropertyParameters {_propertyType = "ExternalReferenceType", _minCount = Nothing, _maxCount = Just 1}),("locator",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Nothing, _maxCount = Nothing})]}),("Hash",Spdx3Class {_classSummary = "A mathematically calculated representation of a grouping of data.", _classDescription = "A hash is a grouping of characteristics unique to the result of applying\na mathematical algorithm that maps data of arbitrary size to a bit\nstring (the hash) and is a one-way function, that is, a function which\nis practically infeasible to invert. This is commonly used for integrity\nchecking of data.", _classMetadata = fromList [("SubclassOf","IntegrityMethod"),("name","Hash")], _classProperties = fromList [("algorithm",Spdx3ClassPropertyParameters {_propertyType = "HashAlgorithm", _minCount = Just 1, _maxCount = Just 1}),("hashValue",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1})]}),("IntegrityMethod",Spdx3Class {_classSummary = "Provides an independently reproducible mechanism that permits\nverification of a specific Element.", _classDescription = "An IntegrityMethod provides an independently reproducible mechanism that\npermits verification of a specific Element that correlates to the data\nin this SPDX document. This identifier enables a recipient to determine\nif anything in the original Element has been changed and eliminates\nconfusion over which version or modification of a specific Element is\nreferenced.", _classMetadata = fromList [("Instantiability","Abstract"),("name","IntegrityMethod")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1})]}),("LifecycleScopedRelationship",Spdx3Class {_classSummary = "MISSING", _classDescription = "TODO", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Relationship"),("name","LifecycleScopedRelationship")], _classProperties = fromList [("scope",Spdx3ClassPropertyParameters {_propertyType = "LifecycleScopeType", _minCount = Just 0, _maxCount = Just 1})]}),("MediaType",Spdx3Class {_classSummary = "Standardized way of indicating the type of content of an Element. A\nString constrained to the RFC 2046 specification.", _classDescription = "The MediaType is a String constrained to the RFC 2046 specification. It\nprovides a standardized way of indicating the type of content of an\nElement. A list of all possible media types is available at\nhttps://www.iana.org/assignments/media-types/media-types.xhtml.", _classMetadata = fromList [("SubclassOf","xsd:string"),("name","MediaType")], _classProperties = fromList []}),("NamespaceMap",Spdx3Class {_classSummary = "A mapping between prefixes and namespace URIs.", _classDescription = "A namespace map allows the creator of a collection of Elements to use\nshorter identifiers (\"prefixes\") instead of URIs to provide a more\nhuman-readable and smaller serialized representation of the Elements.", _classMetadata = fromList [("Instantiability","Concrete"),("name","NamespaceMap")], _classProperties = fromList [("namespace",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 1, _maxCount = Just 1}),("prefix",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1})]}),("Organization",Spdx3Class {_classSummary = "A group of people who work together in an organized way for a shared\npurpose.", _classDescription = "An Organization is a group of people who work together in an organized\nway for a shared purpose.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Agent"),("name","Organization")], _classProperties = fromList []}),("Payload",Spdx3Class {_classSummary = "TODO", _classDescription = "TODO", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","none"),("name","Payload")], _classProperties = fromList [("creationInfo",Spdx3ClassPropertyParameters {_propertyType = "CreationInfo", _minCount = Just 0, _maxCount = Just 1}),("imports",Spdx3ClassPropertyParameters {_propertyType = "ExternalMap", _minCount = Nothing, _maxCount = Nothing}),("namespaces",Spdx3ClassPropertyParameters {_propertyType = "NamespaceMap", _minCount = Nothing, _maxCount = Nothing})]}),("Person",Spdx3Class {_classSummary = "An individual human being.", _classDescription = "A Person is an individual human being.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Agent"),("name","Person")], _classProperties = fromList []}),("PositiveIntegerRange",Spdx3Class {_classSummary = "A tuple of two positive integers that define a range.", _classDescription = "PositiveIntegerRange is a tuple of two positive integers that define a\nrange. \"begin\" must be less than or equal to \"end\".", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","none"),("name","PositiveIntegerRange")], _classProperties = fromList [("begin",Spdx3ClassPropertyParameters {_propertyType = "xsd:positiveInteger", _minCount = Just 1, _maxCount = Just 1}),("end",Spdx3ClassPropertyParameters {_propertyType = "xsd:positiveInteger", _minCount = Just 1, _maxCount = Just 1})]}),("Relationship",Spdx3Class {_classSummary = "Describes a relationship between one or more elements.", _classDescription = "A Relationship is a grouping of characteristics unique to an assertion\nthat one Element is related to one or more other Elements in some way.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Element"),("name","Relationship")], _classProperties = fromList [("completeness",Spdx3ClassPropertyParameters {_propertyType = "RelationshipCompleteness", _minCount = Just 0, _maxCount = Just 1}),("endTime",Spdx3ClassPropertyParameters {_propertyType = "DateTime", _minCount = Just 0, _maxCount = Just 1}),("from",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Just 1}),("relationshipType",Spdx3ClassPropertyParameters {_propertyType = "RelationshipType", _minCount = Just 1, _maxCount = Just 1}),("startTime",Spdx3ClassPropertyParameters {_propertyType = "DateTime", _minCount = Just 0, _maxCount = Just 1}),("to",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 0, _maxCount = Nothing})]}),("SemVer",Spdx3Class {_classSummary = "A string constrained to the SemVer 2.0.0 specification.", _classDescription = "The semantic version is a string that is following the specification of\n[Semantic Versioning 2.0.0](https://semver.org/).", _classMetadata = fromList [("SubclassOf","xsd:string"),("name","SemVer")], _classProperties = fromList []}),("SoftwareAgent",Spdx3Class {_classSummary = "A software agent.", _classDescription = "A SoftwareAgent is a software program that is given the authority\n(similar to a user's authority) to act on a system.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Agent"),("name","SoftwareAgent")], _classProperties = fromList []}),("SpdxDocument",Spdx3Class {_classSummary = "Assembles a collection of Elements under a common string, the name of\nthe document.", _classDescription = "An SpdxDocument assembles a collection of Elements under a common\nstring, the name of the document. Commonly used when representing a unit\nof transfer of SPDX Elements.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Bundle"),("name","SpdxDocument")], _classProperties = fromList [("name",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1})]}),("Tool",Spdx3Class {_classSummary = "An element of hardware and/or software utilized to carry out a\nparticular function.", _classDescription = "A Tool is an element of hardware and/or software utilized to carry out a\nparticular function.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Element"),("name","Tool")], _classProperties = fromList []})]}),("Dataset",Spdx3Profile {_profileSummary = "Everything having to do with datasets.", _profileDescription = "The Dataset namespace defines tbd.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3/Dataset"),("name","Dataset")], _profileProperties = fromList [("anonymizationMethodUsed",Spdx3Property {_propertySummary = "Describes the anonymization methods used.", _propertyDescription = "AnonymizationMethodUsed describes the methods used to anonymize the\ndataset (of fields in the dataset).", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","anonymizationMethodUsed")]}),("confidentialityLevel",Spdx3Property {_propertySummary = "Describes the confidentiality level of the data points contained in the\ndataset.", _propertyDescription = "ConfidentialityLevel describes the levels of confidentiality of the data\npoints contained in the dataset.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ConfidentialityLevelType"),("name","confidentialityLevel")]}),("dataCollectionProcess",Spdx3Property {_propertySummary = "Describes how the dataset was collected.", _propertyDescription = "DataCollectionProcess describes how a dataset was collected. Examples\ninclude the sources from which a dataset was scrapped or the interview\nprotocol that was used for data collection.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","dataCollectionProcess")]}),("dataPreprocessing",Spdx3Property {_propertySummary = "Describes the preprocessing steps that were applied to the raw data to\ncreate the given dataset.", _propertyDescription = "DataPreprocessing describes the various preprocessing steps that were\napplied to the raw data to create the dataset.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","dataPreprocessing")]}),("datasetAvailability",Spdx3Property {_propertySummary = "The field describes the availability of a dataset.", _propertyDescription = "Some datasets are publicly available and can be downloaded directly.\nOthers are only accessible behind a clickthrough, or after filling a\nregistration form. This field will describe the dataset availability\nfrom that perspective.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DatasetAvailabilityType"),("name","datasetAvailability")]}),("datasetNoise",Spdx3Property {_propertySummary = "Describes potentially noisy elements of the dataset.", _propertyDescription = "DatasetNoise describes what kinds of noises a dataset might encompass.\nThe field uses free form text to specify the fields or the samples that\nmight be noisy. Alternatively, it can also be used to describe various\nnoises that could impact the whole dataset.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","datasetNoise")]}),("datasetSize",Spdx3Property {_propertySummary = "Captures the size of the dataset.", _propertyDescription = "DatasetSize Captures how large a dataset is. The size is to be measured\nin bytes.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:nonNegativeInteger"),("name","datasetSize")]}),("datasetType",Spdx3Property {_propertySummary = "Describes the type of the given dataset.", _propertyDescription = "Type describes the datatype contained in the dataset. For example a\ndataset can be a image dataset or a text dataset or sometimes a\nmultimodal dataset that contains multiple types of data", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","datasetType")]}),("datasetUpdateMechanism",Spdx3Property {_propertySummary = "Describes a mechanism to update the dataset.", _propertyDescription = "DatasetUpdateMechanism describes a mechanism to update the dataset.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","datasetUpdateMechanism")]}),("intendedUse",Spdx3Property {_propertySummary = "Describes what the given dataset should be used for.", _propertyDescription = "IntendedUse describes what the given dataset should be used for. Some\ndatasets are collected to be used only for particular purposes. For\nexample, medical data collected from a specific demography might only be\napplicable for training machine learning models to make predictions for\nthat demography. In such a case, the intendedUse field would capture\nthis information. Similarly, if a dataset is collected for building a\nfacial recognition model, the intendedUse field would specify that.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","intendedUse")]}),("knownBias",Spdx3Property {_propertySummary = "Records the biases that the dataset is known to encompass.", _propertyDescription = "KnownBias is a free form text field that describes the different biases\nthat the dataset encompasses.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","knownBias")]}),("sensitivePersonalInformation",Spdx3Property {_propertySummary = "Describes if any sensitive personal information is present in the\ndataset.", _propertyDescription = "SensitivePersonalInformation indicates the presence of sensitive\npersonal data or information that allows drawing conclusions about a\nperson's identity.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","PresenceType"),("name","sensitivePersonalInformation")]}),("sensor",Spdx3Property {_propertySummary = "Describes a sensor used for collecting the data.", _propertyDescription = "Sensor describes a sensor that was used for collecting the data and its\ncalibration value as a key-value pair.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DictionaryEntry"),("name","sensors")]})], _profileVocabularies = fromList [("ConfidentialityLevelType",Spdx3Vocabulary {_vocabularySummary = "Categories of confidentiality level.", _vocabularyDescription = "Describes the different confidentiality levels as given by the [Traffic\nLight Protocol](https://en.wikipedia.org/wiki/Traffic_Light_Protocol).", _vocabularyMetadata = fromList [("name","ConfidentialityLevelType")], _vocabularyEntries = fromList [("Amber","Data points in the dataset can be shared only with specific\norganizations and their clients on a need to know basis."),("Clear","Dataset may be distributed freely, without restriction."),("Green","Dataset can be shared within a community of peers and partners."),("Red","Data points in the dataset are highly confidential and can only be\nshared with named recipients.")]}),("DatasetAvailabilityType",Spdx3Vocabulary {_vocabularySummary = "Availability of dataset", _vocabularyDescription = "Describes the possible types of availability of a dataset, indicating\nwhether the dataset can be directly downloaded, can be assembled using a\nscript for scraping the data, is only available after a clickthrough or\na registration form.", _vocabularyMetadata = fromList [("name","DatasetAvailabilityType")], _vocabularyEntries = fromList [("Clickthrough","the dataset is not publicly available and can only be accessed after\naffirmatively accepting terms on a clickthrough webpage."),("Direct-Download","the dataset is publicly available and can be downloaded directly."),("Query","the dataset is publicly available, but not all at once, and can only be\naccessed through queries which return parts of the dataset."),("Registration","the dataset is not publicly available and an email registration is\nrequired before accessing the dataset, although without an affirmative\nacceptance of terms."),("Scraping-Script","the dataset provider is not making available the underlying data and the\ndataset must be reassembled, typically using the provided script for\nscraping the data.")]})], _profileClasses = fromList [("Dataset",Spdx3Class {_classSummary = "Provides information about the fields in the Dataset profile.", _classDescription = "Metadata information that can be added to a dataset that may be used in\na software or to train/test an AI package.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","/Software/Package"),("name","Dataset")], _classProperties = fromList [("anonymizationMethodUsed",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("confidentialityLevel",Spdx3ClassPropertyParameters {_propertyType = "ConfidentialityLevelType", _minCount = Just 0, _maxCount = Just 1}),("dataCollectionProcess",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("dataPreprocessing",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("datasetAvailability",Spdx3ClassPropertyParameters {_propertyType = "DatasetAvailabilityType", _minCount = Just 0, _maxCount = Just 1}),("datasetNoise",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("datasetSize",Spdx3ClassPropertyParameters {_propertyType = "xsd:nonNegativeInteger", _minCount = Just 0, _maxCount = Just 1}),("datasetType",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("datasetUpdateMechanism",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("intendedUse",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("knownBias",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("sensitivePersonalInformation",Spdx3ClassPropertyParameters {_propertyType = "PresenceType", _minCount = Just 0, _maxCount = Just 1}),("sensor",Spdx3ClassPropertyParameters {_propertyType = "/Core/DictionaryEntry", _minCount = Just 0, _maxCount = Nothing})]})]}),("Licensing",Spdx3Profile {_profileSummary = "Additional metadata relating to software licensing.", _profileDescription = "The Licensing namespace defines metadata fields applicable to software\nlicensing. It also defines the classes and properties that comprise the\nSPDX License Expression syntax and that relate to the SPDX License List.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3/Licensing"),("name","Licensing")], _profileProperties = fromList [("additionComment",Spdx3Property {_propertySummary = "Identifies general comments about the LicenseAddition.", _propertyDescription = "An additionComment for a LicenseAddition describes general factual\ninformation about the LicenseAddition. It should not contain information\n(or links to information) that includes any kind of interpretation about\nthe meaning or effect of the License, even if written by the license\naddition's author.\n\nExamples of information for an additionComment may include the\nfollowing:\n\n-   If the LicenseAddition's identifier is deprecated, it may briefly\n    explain the reason for deprecation.\n-   It may include the date of release, if identified, for\n    LicenseAdditions with multiple versions.\n-   It may include links to other official language translations for the\n    LicenseAddition.\n-   It may include a reference to the License(s) with which this\n    LicenseAddition is typically used.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","additionComment")]}),("additionId",Spdx3Property {_propertySummary = "Provides a short, unique identifier to refer to a LicenseAddition.", _propertyDescription = "An additionId contains a human-readable, short-form identifier for a\nLicenseAddition. It may only include letters, numbers, period (\".\") and\nhyphen (\"-\") characters.\n\nFor a ListedLicenseException, the licenseId will be as specified on the\n[SPDX Exceptions List](https://spdx.org/licenses/exceptions-index.html)\nfor the particular exception.\n\nFor a CustomLicenseAddition, the short-form identifier must begin with\nthe prefix `AdditionRef-` and must be unique within the applicable SPDX\nnamespace. The short-form identifier may be preceded by an SPDX\nnamespace or a fully-qualified URI prefix.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","additionId")]}),("additionName",Spdx3Property {_propertySummary = "Identifies the full name of a LicenseAddition.", _propertyDescription = "An additionName contains the full name of a LicenseAddition, preferably\nusing the title found in the applicable license addition text or file,\nor as otherwise specified by the LicenseAddition's author or steward.\n\nWhen no such title is specified, using a name from another well-known\nsource or list of licenses additions (such as OSI or Fedora) is\nsuggested.\n\nIf no official or common name is known, any name may be used to aid in\ndistinguishing the LicenseAddition from other LicenseAdditions.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","additionName")]}),("additionText",Spdx3Property {_propertySummary = "Identifies the full text of a LicenseAddition.", _propertyDescription = "An additionText contains the plain text of the LicenseAddition, without\ntemplating or other similar markup.\n\nUsers of the additionText for a License can apply the SPDX Matching\nGuidelines when comparing it to another text for matching purposes.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","additionText")]}),("deprecatedVersion",Spdx3Property {_propertySummary = "Specifies the SPDX License List version in which this license or\nexception identifier was deprecated.", _propertyDescription = "A deprecatedVersion for a ListedLicense or ListedLicenseException on the\nSPDX License List specifies which version release of the License List\nwas the first one in which it was marked as deprecated.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","deprecatedVersion")]}),("isDeprecatedAdditionId",Spdx3Property {_propertySummary = "Specifies whether an additional text identifier has been marked as\ndeprecated.", _propertyDescription = "The isDeprecatedAdditionId property specifies whether an identifier for\na LicenseAddition has been marked as deprecated. If the property is not\ndefined, then it is presumed to be false (i.e., not deprecated).\n\nIf the LicenseAddition is included on the SPDX Exceptions List, then the\n`deprecatedVersion` property indicates on which version release of the\nExceptions List it was first marked as deprecated.\n\n\"Deprecated\" in this context refers to deprecating the use of the\n*identifier*, not the underlying license addition. In other words, even\nif a LicenseAddition's author or steward has stated that a particular\nLicenseAddition generally should not be used, that would *not* mean that\nthe LicenseAddition's identifier is \"deprecated.\" Rather, a\nLicenseAddition operator is typically marked as \"deprecated\" when it is\ndetermined that use of another identifier is preferable.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:boolean"),("name","isDeprecatedAdditionId")]}),("isDeprecatedLicenseId",Spdx3Property {_propertySummary = "Specifies whether a license or additional text identifier has been\nmarked as deprecated.", _propertyDescription = "The isDeprecatedLicenseId property specifies whether an identifier for a\nLicense or LicenseAddition has been marked as deprecated. If the\nproperty is not defined, then it is presumed to be false (i.e., not\ndeprecated).\n\nIf the License or LicenseAddition is included on the SPDX License List,\nthen the `deprecatedVersion` property indicates on which version release\nof the License List it was first marked as deprecated.\n\n\"Deprecated\" in this context refers to deprecating the use of the\n*identifier*, not the underlying license. In other words, even if a\nLicense's author or steward has stated that a particular License\ngenerally should not be used, that would *not* mean that the License's\nidentifier is \"deprecated.\" Rather, a License or LicenseAddition\noperator is typically marked as \"deprecated\" when it is determined that\nuse of another identifier is preferable.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:boolean"),("name","isDeprecatedLicenseId")]}),("isFsfLibre",Spdx3Property {_propertySummary = "Specifies whether the License is listed as free by the [Free Software\nFoundation (FSF)](https://fsf.org).", _propertyDescription = "isFsfLibre specifies whether the [Free Software Foundation\nFSF](https://fsf.org) has listed this License as \"free\" in their\ncommentary on licenses, located at the time of this writing at\nhttps://www.gnu.org/licenses/license-list.en.html.\n\nA value of \"true\" indicates that the FSF has listed this License as\n*free*.\n\nA value of \"false\" indicates that the FSF has listed this License as\n*not free*.\n\nIf the isFsfLibre field is not specified, the SPDX data creator makes no\nassertions about whether the License is listed in the FSF's commentary.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:boolean"),("name","isFsfLibre")]}),("isOsiApproved",Spdx3Property {_propertySummary = "Specifies whether the License is listed as approved by the [Open Source\nInitiative (OSI)](https://opensource.org).", _propertyDescription = "isOsiApproved specifies whether the [Open Source Initiative\n(OSI)](https://opensource.org) has listed this License as \"approved\" in\ntheir list of OSI Approved Licenses, located at the time of this writing\nat https://opensource.org/licenses/.\n\nA value of \"true\" indicates that the OSI has listed this License as\napproved.\n\nA value of \"false\" indicates that the OSI has not listed this License as\napproved.\n\nIf the isOsiApproved field is not specified, the SPDX data creator makes\nno assertions about whether the License is approved by the OSI.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:boolean"),("name","isOsiApproved")]}),("licenseComment",Spdx3Property {_propertySummary = "Identifies general comments about the License.", _propertyDescription = "A licenseComment describes general factual information about the\nLicense. It should not contain information (or links to information)\nthat includes any kind of interpretation about the meaning or effect of\nthe License, even if written by the license's author.\n\nExamples of information for a licenseComment may include the following:\n\n-   If the License's identifier is deprecated, it may briefly explain\n    the reason for deprecation.\n-   It may include the date of release, if identified, for Licenses with\n    multiple versions.\n-   It may include links to other official language translations for the\n    License.\n-   For LicenseAdditions, it may include a reference to the License(s)\n    with which this additional text is typically used.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","licenseComment")]}),("licenseId",Spdx3Property {_propertySummary = "Provides a short, unique identifier to refer to a License.", _propertyDescription = "A licenseId contains a human-readable, short-form license identifier for\na License. It may only include letters, numbers, period (\".\") and hyphen\n(\"-\") characters.\n\nFor a ListedLicense, the licenseId will be as specified on the [SPDX\nLicense List](https://spdx.org/licenses) for the particular license.\n\nFor a CustomLicense, the short-form license identifer must begin with\nthe prefix `LicenseRef-` and must be unique within the applicable SPDX\nnamespace. The short-form license ID may be preceded by an SPDX\nnamespace or a fully-qualified URI prefix.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","licenseId")]}),("licenseName",Spdx3Property {_propertySummary = "Identifies the full name of a License.", _propertyDescription = "A licenseName contains the full name of a License, preferably using the\ntitle found in the applicable license text or file, or as otherwise\nspecified by the License's author or steward.\n\nWhen no such title is specified, using a name from another well-known\nsource or list of licenses (such as OSI or Fedora) is suggested.\n\nIf no official or common name is known, any name may be used to aid in\ndistinguishing the License from other Licenses.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","licenseName")]}),("licenseText",Spdx3Property {_propertySummary = "Identifies the full text of a License.", _propertyDescription = "A licenseText contains the plain text of the License, without templating\nor other similar markup.\n\nUsers of the licenseText for a License can apply the SPDX Matching\nGuidelines when comparing it to another text for matching purposes.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","licenseText")]}),("listVersionAdded",Spdx3Property {_propertySummary = "Specifies the SPDX License List version in which this ListedLicense or\nListedLicenseException identifier was first added.", _propertyDescription = "A listVersionAdded for a ListedLicense or ListedLicenseException on the\nSPDX License List specifies which version release of the License List\nwas the first one in which it was included.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","listVersionAdded")]}),("member",Spdx3Property {_propertySummary = "A license expression participating in a license set.", _propertyDescription = "A member is a license expression participating in a conjuctive (of type\nConjunctiveLicenseSet) or a disjunctive (of type DisjunctiveLicenseSet)\nlicense set.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","AnyLicenseInfo"),("name","member")]}),("obsoletedBy",Spdx3Property {_propertySummary = "Specifies the licenseId that is preferred to be used in place of a\ndeprecated License or LicenseAddition.", _propertyDescription = "An obsoletedBy value for a deprecated License or LicenseAddition\nspecifies the licenseId of the replacement License or LicenseAddition\nthat is preferred to be used in its place. It should use the same format\nas specified for a licenseId.\n\nThe License's or LicenseAddition's comment value may include more\ninformation about the reason why the licenseId specified in the\nobsoletedBy value is preferred.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","obsoletedBy")]}),("seeAlso",Spdx3Property {_propertySummary = "Contains a URL where the License or LicenseAddition can be found in use.", _propertyDescription = "A seeAlso defines a cross-reference with a URL where the License or\nLicenseAddition can be found in use by one or a few projects.\n\nIf applicable, it should include a URL where the license text is posted\nby the license steward, particularly if the license steward has made\navailable a \"canonical\" primary URL for the license text.\n\nIf the license is OSI approved, a seeAlso should be included with the\nURL for the license's listing on the OSI website.\n\nThe seeAlso URL may refer to a previously-available URL for the License\nor LicenseAddition which is no longer active.\n\nWhere applicable, the seeAlso URL should include the license text in its\nnative language. seeAlso URLs to English or other translations may be\nincluded where multiple, equivalent official translations exist.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","seeAlso")]}),("standardAdditionTemplate",Spdx3Property {_propertySummary = "Identifies the full text of a LicenseAddition, in SPDX templating\nformat.", _propertyDescription = "A standardAdditionTemplate contains a license addition template which\ndescribes sections of the LicenseAddition text which can be varied. See\nthe Legacy Text Template format section of the SPDX specification for\nformat information.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","standardAdditionTemplate")]}),("standardLicenseHeader",Spdx3Property {_propertySummary = "Provides a License author's preferred text to indicate that a file is\ncovered by the License.", _propertyDescription = "A standardLicenseHeader contains the plain text of the License author's\npreferred wording to be used, typically in a source code file's header\ncomments or similar location, to indicate that the file is subject to\nthe specified License.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","standardLicenseHeader")]}),("standardLicenseTemplate",Spdx3Property {_propertySummary = "Identifies the full text of a License, in SPDX templating format.", _propertyDescription = "A standardLicenseTemplate contains a license template which describes\nsections of the License text which can be varied. See the Legacy Text\nTemplate format section of the SPDX specification for format\ninformation.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","standardLicenseTemplate")]}),("subjectAddition",Spdx3Property {_propertySummary = "A LicenseAddition participating in a 'with addition' model.", _propertyDescription = "A subjectAddition is a LicenseAddition which is subject to a 'with\nadditional text' effect (WithAdditionOperator).", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","LicenseAddition"),("name","subjectAddition")]}),("subjectLicense",Spdx3Property {_propertySummary = "A License participating in a 'with addition' or 'or later' model.", _propertyDescription = "A subjectLicense is a License which is subject to either an 'or later'\neffect (OrLaterOperator) or a 'with additional text' effect\n(WithAdditionOperator).", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","License"),("name","subjectLicense")]})], _profileVocabularies = fromList [], _profileClasses = fromList [("AnyLicenseInfo",Spdx3Class {_classSummary = "Abstract class representing a license combination consisting of one or\nmore licenses (optionally including additional text), which may be\ncombined according to the SPDX license expression syntax.", _classDescription = "An AnyLicenseInfo is used by a licensing field for a software package,\nfile or snippet when its value is not NOASSERTION or NONE. It can be a\nsingle license (either on the SPDX License List or a custom-defined\nlicense); a single license with an \"or later\" operator applied; the\nforegoing with additional text applied; or a set of licenses combined by\napplying \"AND\" and \"OR\" operators recursively.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","LicenseField"),("name","AnyLicenseInfo")], _classProperties = fromList []}),("ConjunctiveLicenseSet",Spdx3Class {_classSummary = "Portion of an AnyLicenseInfo representing a set of licensing information\nwhere all elements apply.", _classDescription = "A ConjunctiveLicenseSet indicates that *each* of its subsidiary\nAnyLicenseInfos apply. In other words, a ConjunctiveLicenseSet of two or\nmore licenses represents a licensing situation where *all* of the\nspecified licenses are to be complied with. It is represented in the\nSPDX License Expression Syntax by the `AND` operator.\n\nIt is syntactically correct to specify a ConjunctiveLicenseSet where the\nsubsidiary AnyLicenseInfos may be \"incompatible\" according to a\nparticular interpretation of the corresponding Licenses. The SPDX\nLicense Expression Syntax does not take into account interpretation of\nlicense texts, which is left to the consumer of SPDX data to determine\nfor themselves.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","AnyLicenseInfo"),("name","ConjunctiveLicenseSet")], _classProperties = fromList [("member",Spdx3ClassPropertyParameters {_propertyType = "AnyLicenseInfo", _minCount = Just 2, _maxCount = Nothing})]}),("CustomLicense",Spdx3Class {_classSummary = "A license that is not listed on the SPDX License List.", _classDescription = "A CustomLicense represents a License that is not listed on the SPDX\nLicense List at https://spdx.org/licenses, and is therefore defined by\nan SPDX data creator.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","License"),("name","CustomLicense")], _classProperties = fromList []}),("CustomLicenseAddition",Spdx3Class {_classSummary = "A license addition that is not listed on the SPDX Exceptions List.", _classDescription = "A CustomLicenseAddition represents an addition to a License that is not\nlisted on the SPDX Exceptions List at\nhttps://spdx.org/licenses/exceptions-index.html, and is therefore\ndefined by an SPDX data creator.\n\nIt is intended to represent additional language which is meant to be\nadded to a License, but which is not itself a standalone License.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseAddition"),("name","CustomLicenseAddition")], _classProperties = fromList []}),("DisjunctiveLicenseSet",Spdx3Class {_classSummary = "Portion of an AnyLicenseInfo representing a set of licensing information\nwhere only any one of the elements applies.", _classDescription = "A DisjunctiveLicenseSet indicates that *only one* of its subsidiary\nAnyLicenseInfos is required to apply. In other words, a\nDisjunctiveLicenseSet of two or more licenses represents a licensing\nsituation where *only one* of the specified licenses are to be complied\nwith. A consumer of SPDX data would typically understand this to permit\nthe recipient of the licensed content to choose which of the\ncorresponding license they would prefer to use. It is represented in the\nSPDX License Expression Syntax by the `OR` operator.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","AnyLicenseInfo"),("name","DisjunctiveLicenseSet")], _classProperties = fromList [("member",Spdx3ClassPropertyParameters {_propertyType = "AnyLicenseInfo", _minCount = Just 2, _maxCount = Nothing})]}),("License",Spdx3Class {_classSummary = "Abstract class for the portion of an AnyLicenseInfo representing a\nlicense.", _classDescription = "A License represents a license text, whether listed on the SPDX License\nList (ListedLicense) or defined by an SPDX data creator (CustomLicense).", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","AnyLicenseInfo"),("name","License")], _classProperties = fromList [("isDeprecatedLicenseId",Spdx3ClassPropertyParameters {_propertyType = "xsd:boolean", _minCount = Just 0, _maxCount = Just 1}),("isFsfLibre",Spdx3ClassPropertyParameters {_propertyType = "xsd:boolean", _minCount = Just 0, _maxCount = Just 1}),("isOsiApproved",Spdx3ClassPropertyParameters {_propertyType = "xsd:boolean", _minCount = Just 0, _maxCount = Just 1}),("licenseComment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("licenseId",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("licenseName",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("licenseText",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("obsoletedBy",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("seeAlso",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Nothing}),("standardLicenseHeader",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("standardLicenseTemplate",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("LicenseAddition",Spdx3Class {_classSummary = "Abstract class for additional text intended to be added to a License,\nbut which is not itself a standalone License.", _classDescription = "A LicenseAddition represents text which is intended to be added to a\nLicense as additional text, but which is not itself intended to be a\nstandalone License.\n\nIt may be an exception which is listed on the SPDX Exceptions List\n(ListedLicenseException), or may be any other additional text (as an\nexception or otherwise) which is defined by an SPDX data creator\n(CustomLicenseAddition).", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","none"),("name","LicenseAddition")], _classProperties = fromList [("additionComment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("additionId",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("additionName",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("additionText",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("isDeprecatedAdditionId",Spdx3ClassPropertyParameters {_propertyType = "xsd:boolean", _minCount = Just 0, _maxCount = Just 1}),("obsoletedBy",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("seeAlso",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Nothing}),("standardAdditionTemplate",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("LicenseField",Spdx3Class {_classSummary = "Base abstract class used for all fields that can take a value of either\na license expression, NOASSERTION, or NONE.", _classDescription = "A LicenseField is the primary value that is used by a licensing field\nfor a software Package, File or Snippet. It represents either a license\nexpression, or the values NOASSERTION or NONE. The specific meanings of\nNOASSERTION or NONE for the particular licensing field are defined in\nthe corresponding property description.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","none"),("name","LicenseField")], _classProperties = fromList []}),("ListedLicense",Spdx3Class {_classSummary = "A license that is listed on the SPDX License List.", _classDescription = "A ListedLicense represents a License that is listed on the SPDX License\nList at https://spdx.org/licenses.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","License"),("name","ListedLicense")], _classProperties = fromList [("deprecatedVersion",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("listVersionAdded",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("ListedLicenseException",Spdx3Class {_classSummary = "A license exception that is listed on the SPDX Exceptions list.", _classDescription = "A ListedLicenseException represents an exception to a License (in other\nwords, an exception to a license condition or an additional permission\nbeyond those granted in a License) which is listed on the SPDX\nExceptions List at https://spdx.org/licenses/exceptions-index.html.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseAddition"),("name","ListedLicenseException")], _classProperties = fromList [("deprecatedVersion",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("listVersionAdded",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("NoAssertionLicense",Spdx3Class {_classSummary = "Concrete class representing an absence of an assertion about license\ninformation.", _classDescription = "A NoAssertionLicense is the primary value that is used by a\nconcludedLicense or declaredLicense field that indicates that the SPDX\ndata creator is making no assertion about the license information for\nthe corresponding software Package, File or Snippet.\n\nThe specific meaning of NoAssertionLicense in the context of a\nconcludedLicense or declaredLicense field is more fully set forth in the\nProperty definitions for those fields.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseField"),("name","NoAssertionLicense")], _classProperties = fromList []}),("NoneLicense",Spdx3Class {_classSummary = "Concrete class representing an assertion that no license information is\npresent, as applicable.", _classDescription = "A NoneLicense is the primary value that is used by a concludedLicense or\ndeclaredLicense field that indicates the absence of license information\nfrom the corresponding software Package, File or Snippet.\n\nThe specific meaning of NoneLicense in the context of a concludedLicense\nor declaredLicense field is more fully set forth in the Property\ndefinitions for those fields.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseField"),("name","NoneLicense")], _classProperties = fromList []}),("OrLaterOperator",Spdx3Class {_classSummary = "Portion of an AnyLicenseInfo representing this version, or any later\nversion, of the indicated License.", _classDescription = "An OrLaterOperator indicates that this portion of the AnyLicenseInfo\nrepresents either (1) the specified version of the corresponding\nLicense, or (2) any later version of that License. It is represented in\nthe SPDX License Expression Syntax by the `+` operator.\n\nIt is context-dependent, and unspecified by SPDX, as to what constitutes\na \"later version\" of any particular License. Some Licenses may not be\nversioned, or may not have clearly-defined ordering for versions. The\nconsumer of SPDX data will need to determine for themselves what meaning\nto attribute to a \"later version\" operator for a particular License.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","AnyLicenseInfo"),("name","OrLaterOperator")], _classProperties = fromList [("subjectLicense",Spdx3ClassPropertyParameters {_propertyType = "License", _minCount = Just 1, _maxCount = Just 1})]}),("WithAdditionOperator",Spdx3Class {_classSummary = "Portion of an AnyLicenseInfo representing a License which has additional\ntext applied to it", _classDescription = "A WithAdditionOperator indicates that the designated License is subject\nto the designated LicenseAddition, which might be a license exception on\nthe SPDX Exceptions List (ListedLicenseException) or may be other\nadditional text (CustomLicenseAddition). It is represented in the SPDX\nLicense Expression Syntax by the `WITH` operator.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","AnyLicenseInfo"),("name","WithAdditionOperator")], _classProperties = fromList [("subjectAddition",Spdx3ClassPropertyParameters {_propertyType = "LicenseAddition", _minCount = Just 1, _maxCount = Just 1}),("subjectLicense",Spdx3ClassPropertyParameters {_propertyType = "License", _minCount = Just 1, _maxCount = Just 1})]})]}),("Security",Spdx3Profile {_profileSummary = "The Security Profile captures security related information.", _profileDescription = "The Security Profile captures security related information.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3/Security"),("name","Security")], _profileProperties = fromList [("actionStatement",Spdx3Property {_propertySummary = "Provides advise on how to mitigate or remediate a vulnerability when a\nVEX product is affected by it.", _propertyDescription = "When an element is referenced with a\nVexAffectedVulnAssessmentRelationship, the relationship MUST include one\nactionStatement that SHOULD describe actions to remediate or mitigate\nthe vulnerability.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","actionStatement")]}),("actionStatementTime",Spdx3Property {_propertySummary = "Records the time when a recommended action was communicated in a VEX\nstatement to mitigate a vulnerability.", _propertyDescription = "When a VEX statement communicates an affected status, the author MUST\ninclude an action statement with a recommended action to help mitigate\nthe vulnerability's impact. The actionStatementTime property records the\ntime when the action statement was first communicated.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DateTime"),("name","actionStatementTime")]}),("assessedElement",Spdx3Property {_propertySummary = "Specifies an element contained in a piece of software where a\nvulnerability was found.", _propertyDescription = "Specifies subpackages, files or snippets referenced by a security\nassessment to specify the precise location where a vulnerability was\nfound.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","/Core/Element"),("name","assessedElement")]}),("catalogType",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A catalogType is a mandatory value and must select one of the two\nentries in the `ExploitCatalogType.md` vocabulary.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ExploitCatalogType"),("name","catalogType")]}),("decisionType",Spdx3Property {_propertySummary = "Provide the enumeration of possible decisions in the\nStakeholder-Specific Vulnerability Categorization (SSVC) decision tree\n<https://www.cisa.gov/sites/default/files/publications/cisa-ssvc-guide%20508c.pdf>", _propertyDescription = "A decisionType is a mandatory value and must select one of the four\nentries in the `SsvcDecisionType.md` vocabulary.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SsvcDecisionType"),("name","decisionType")]}),("exploited",Spdx3Property {_propertySummary = "Describe that a CVE is known to have an exploit because it's been listed\nin an exploit catalog.", _propertyDescription = "This field is set when a CVE is listed in an exploit catalog.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:boolean"),("name","exploited")]}),("impactStatement",Spdx3Property {_propertySummary = "Explains why a VEX product is not affected by a vulnerability. It is an\nalternative in VexNotAffectedVulnAssessmentRelationship to the\nmachine-readable justification label.", _propertyDescription = "When a VEX product element is related with a\nVexNotAffectedVulnAssessmentRelationship and a machine readable\njustification label is not provided, then an impactStatement that\nfurther explains how or why the prouct(s) are not affected by the\nvulnerability must be provided.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","impactStatement")]}),("impactStatementTime",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DateTime"),("name","impactStatementTime")]}),("justificationType",Spdx3Property {_propertySummary = "Impact justification label to be used when linking a vulnerability to an\nelement representing a VEX product with a\nVexNotAffectedVulnAssessmentRelationship relationship.", _propertyDescription = "When stating that an element is not affected by a vulnerability, the\nVexNotAffectedVulnAssessmentRelationship must include a justification\nfrom the machine-readable labels catalog informing the reason the\nelement is not impacted.\n\nimpactStatement which is a string with English prose can be used instead\nor as complementary to the justification label, but one of both MUST be\ndefined.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","VexJustificationType"),("name","justificationType")]}),("locator",Spdx3Property {_propertySummary = "Provides the location of an exploit catalog.", _propertyDescription = "A locator provides the location of an exploit catalog.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","locator")]}),("modifiedTime",Spdx3Property {_propertySummary = "Specifies a time when a vulnerability assessment was modified", _propertyDescription = "Specifies a time when a vulnerability assessment was last modified.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DateTime"),("name","modifiedTime")]}),("probability",Spdx3Property {_propertySummary = "A probability score between 0 and 1 of a vulnerability being exploited.", _propertyDescription = "The probability score between 0 and 1 (0 and 100%) estimating the\nlikelihood that a vulnerability will be exploited in the next 12 months.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:decimal"),("name","probability")]}),("publishedTime",Spdx3Property {_propertySummary = "Specifies the time when a vulnerability was published.", _propertyDescription = "Specifies the time when a vulnerability was first published.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DateTime"),("name","publishedTime")]}),("score",Spdx3Property {_propertySummary = "Provides a numerical (0-10) representation of the severity of a\nvulnerability.", _propertyDescription = "The score provides information on the severity of a vulnerability per\nthe Common Vulnerability Scoring System as defined on\n[https://www.first.org/cvss](https://www.first.org/cvss/).", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","score")]}),("severity",Spdx3Property {_propertySummary = "The severity of a vulnerability in relation to a piece of software.", _propertyDescription = "The severity field provides a human readable string, a label that can be\nused as an English adjective that qualifies its numerical score.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","severity")]}),("statusNotes",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","statusNotes")]}),("suppliedBy",Spdx3Property {_propertySummary = "Identifies who or what supplied the vulnerability assessment\nrelationship.", _propertyDescription = "Identify the actual distribution source for the vulnerability assessment\nrelationship being referenced.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","/Core/Agent"),("name","suppliedBy")]}),("vector",Spdx3Property {_propertySummary = "Specifies the vector string of a vulnerability.", _propertyDescription = "Sepcifies the vector string of a vulnerability, a string combining\nmetrics from an assessment of its severity.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","vector")]}),("vexVersion",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","vexVersion")]}),("withdrawnTime",Spdx3Property {_propertySummary = "Specified the time and date when a vulnerability was withdrawn.", _propertyDescription = "Specified the time and date when a vulnerability was withdrawn.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/DateTime"),("name","withdrawnTime")]})], _profileVocabularies = fromList [("ExploitCatalogType",Spdx3Vocabulary {_vocabularySummary = "Specifies the exploit catalog type.", _vocabularyDescription = "ExploitCatalogType specifies the type of exploit catalog that a\nvulnerability is listed in.", _vocabularyMetadata = fromList [("name","ExploitCatalogType")], _vocabularyEntries = fromList [("kev","CISA's Known Exploited Vulnerability (KEV) Catalog"),("other","Other exploit catalogs")]}),("SsvcDecisionType",Spdx3Vocabulary {_vocabularySummary = "Specifies the SSVC decision type.", _vocabularyDescription = "SsvcDecisionType specifies the type of decision that's been made\naccording to the Stakeholder-Specific Vulnerability Categorization\n(SSVC) system\n<https://www.cisa.gov/stakeholder-specific-vulnerability-categorization-ssvc>", _vocabularyMetadata = fromList [("name","SsvcDecisionType")], _vocabularyEntries = fromList [("act","The vulnerability requires attention from the organization's internal,\nsupervisory-level and leadership-level individuals. Necessary actions\ninclude requesting assistance or information about the vulnerability, as\nwell as publishing a notification either internally and/or externally.\nTypically, internal groups would meet to determine the overall response\nand then execute agreed upon actions. CISA recommends remediating Act\nvulnerabilities as soon as possible."),("attend","The vulnerability requires attention from the organization's internal,\nsupervisory-level individuals. Necessary actions include requesting\nassistance or information about the vulnerability, and may involve\npublishing a notification either internally and/or externally. CISA\nrecommends remediating Attend vulnerabilities sooner than standard\nupdate timelines."),("track","The vulnerability does not require action at this time. The organization\nwould continue to track the vulnerability and reassess it if new\ninformation becomes available. CISA recommends remediating Track\nvulnerabilities within standard update timelines."),("trackStar","(Track\\* in the SSVC spec) The vulnerability contains specific\ncharacteristics that may require closer monitoring for changes. CISA\nrecommends remediating Track\\* vulnerabilities within standard update\ntimelines.")]}),("VexJustificationType",Spdx3Vocabulary {_vocabularySummary = "Specifies the VEX justification type.", _vocabularyDescription = "VexJustificationType specifies the type of Vulnerability Exploitability\neXchange (VEX) justification.", _vocabularyMetadata = fromList [("name","VexJustificationType")], _vocabularyEntries = fromList [("componentNotPresent","The software is not affected because the vulnerable component is not in\nthe product."),("inlineMitigationsAlreadyExist","Built-in inline controls or mitigations prevent an adversary from\nleveraging the vulnerability."),("vulnerableCodeCannotBeControlledByAdversary","The vulnerable component is present, and the component contains the\nvulnerable code. However, vulnerable code is used in such a way that an\nattacker cannot mount any anticipated attack."),("vulnerableCodeNotInExecutePath","The affected code is not reachable through the execution of the code,\nincluding non-anticipated states of the product."),("vulnerableCodeNotPresent","The product is not affected because the code underlying the\nvulnerability is not present in the product.")]})], _profileClasses = fromList [("CvssV2VulnAssessmentRelationship",Spdx3Class {_classSummary = "Provides a CVSS version 2.0 assessment for a vulnerability.", _classDescription = "A CvssV2VulnAssessmentRelationship relationship describes the determined\nscore and vector of a vulnerability using version 2.0 of the Common\nVulnerability Scoring System (CVSS) as defined on\n<https://www.first.org/cvss/v2/guide>. It is intented to communicate the\nresults of using a CVSS calculator.\n\n**Constraints**\n\n-   The value of severity must be one of 'low', 'medium' or 'high'\n-   The relationship type must be set to hasAssessmentFor.\n\n**Syntax**\n\n`json {   \"@type\": \"CvssV2VulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:cvssv2-cve-2020-28498\",   \"relationshipType\": \"hasAssessmentFor\",   \"score\": 4.3,   \"vector\": \"(AV:N/AC:M/Au:N/C:P/I:N/A:N)\",   \"severity\": \"low\",   \"from\": \"urn:spdx.dev:vuln-cve-2020-28498\",   \"to\": [\"urn:product-acme-application-1.3\"],   \"assessedElement\": \"urn:npm-elliptic-6.5.2\",   \"externalReferences\": [     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityAdvisory\",       \"locator\": \"https://nvd.nist.gov/vuln/detail/CVE-2020-28498\"     },     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityAdvisory\",       \"locator\": \"https://snyk.io/vuln/SNYK-JS-ELLIPTIC-1064899\"     },     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityFix\",       \"locator\": \"https://github.com/indutny/elliptic/commit/441b742\"     }   ],   \"suppliedBy\": [\"urn:spdx.dev:agent-my-security-vendor\"],   \"publishedTime\": \"2023-05-06T10:06:13Z\" }, {   \"@type\": \"Relationship\",   \"@id\": \"urn:spdx.dev:vulnAgentRel-1\",     \"relationshipType\": \"publishedBy\",     \"from\": \"urn:spdx.dev:cvssv2-cve-2020-28498\",   \"to\": [\"urn:spdx.dev:agent-snyk\"],   \"startTime\": \"2021-03-08T16:06:50Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VulnAssessmentRelationship"),("name","CvssV2VulnAssessmentRelationship")], _classProperties = fromList [("score",Spdx3ClassPropertyParameters {_propertyType = "xsd:decimal", _minCount = Just 1, _maxCount = Just 1}),("severity",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("vector",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("CvssV3VulnAssessmentRelationship",Spdx3Class {_classSummary = "Provides a CVSS version 3.x assessment for a vulnerability.", _classDescription = "A CvssV3VulnAssessmentRelationship relationship describes the determined\nscore, severity, and vector of a vulnerability using version 3.1 of the\nCommon Vulnerability Scoring System (CVSS) as defined on\n<https://www.first.org/cvss/v3.1/specification-document>. It is intented\nto communicate the results of using a CVSS calculator.\n\n**Constraints**\n\n-   The value of severity must be one of 'none', 'low', 'medium', 'high'\n    or 'critical'.\n-   Absence of the property shall be interpreted as 'none'.\n-   The relationship type must be set to hasAssessmentFor.\n\n**Syntax**\n\n`json {   \"@type\": \"CvssV3VulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:cvssv3-cve-2020-28498\",   \"relationshipType\": \"hasAssessmentFor\",   \"severity\": \"medium\",   \"score\": 6.8,   \"vector\": \"CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N\",   \"from\": \"urn:spdx.dev:vuln-cve-2020-28498\",   \"to\": [\"urn:product-acme-application-1.3\"],   \"assessedElement\": \"urn:npm-elliptic-6.5.2\",   \"externalReferences\": [     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityAdvisory\",       \"locator\": \"https://nvd.nist.gov/vuln/detail/CVE-2020-28498\"     },     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityAdvisory\",       \"locator\": \"https://snyk.io/vuln/SNYK-JS-ELLIPTIC-1064899\"     },     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityFix\",       \"locator\": \"https://github.com/indutny/elliptic/commit/441b742\"     }   ],   \"suppliedBy\": [\"urn:spdx.dev:agent-my-security-vendor\"],   \"publishedTime\": \"2023-05-06T10:06:13Z\" }, {   \"@type\": \"Relationship\",   \"@id\": \"urn:spdx.dev:vulnAgentRel-1\",   \"relationshipType\": \"publishedBy\",   \"from\": \"urn:spdx.dev:cvssv3-cve-2020-28498\",   \"to\": \"urn:spdx.dev:agent-snyk\",   \"startTime\": \"2021-03-08T16:06:50Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VulnAssessmentRelationship"),("name","CvssV3VulnAssessmentRelationship")], _classProperties = fromList [("score",Spdx3ClassPropertyParameters {_propertyType = "xsd:decimal", _minCount = Just 1, _maxCount = Just 1}),("severity",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("vector",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("EpssVulnAssessmentRelationship",Spdx3Class {_classSummary = "Provides an EPSS assessment for a vulnerability.", _classDescription = "An EpssVulnAssessmentRelationship relationship describes the likelihood\nor probability that a vulnerability will be exploited in the wild using\nthe Exploit Prediction Scoring System (EPSS) as defined on\n<https://www.first.org/epss/model>.\n\n**Constraints**\n\n-   The relationship type must be set to hasAssessmentFor.\n\n**Syntax**\n\n`json {   \"@type\": \"EpssVulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:epss-1\",   \"relationshipType\": \"hasAssessmentFor\",   \"probability\": 80,   \"from\": \"urn:spdx.dev:vuln-cve-2020-28498\",   \"to\": [\"urn:product-acme-application-1.3\"],   \"suppliedBy\": [\"urn:spdx.dev:agent-jane-doe\"],   \"publishedTime\": \"2021-03-09T11:04:53Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VulnAssessmentRelationship"),("name","EpssVulnAssessmentRelationship")], _classProperties = fromList [("probability",Spdx3ClassPropertyParameters {_propertyType = "xsd:nonNegativeInteger", _minCount = Just 1, _maxCount = Just 1}),("severity",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("ExploitCatalogVulnAssessmentRelationship",Spdx3Class {_classSummary = "Provides an exploit assessment of a vulnerability.", _classDescription = "An ExploitCatalogVulnAssessmentRelationship describes if a vulnerability\nis listed in any exploit catalog such as the CISA Known Exploited\nVulnerabilities Catalog (KEV)\n<https://www.cisa.gov/known-exploited-vulnerabilities-catalog>.\n\n**Constraints**\n\n-   The relationship type must be set to hasAssessmentFor.\n\n**Syntax**\n\n`json {   \"@type\": \"ExploitCatalogVulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:exploit-catalog-1\",   \"relationshipType\": \"hasAssessmentFor\",   \"catalogType\": \"kev\",   \"locator\": \"https://www.cisa.gov/known-exploited-vulnerabilities-catalog\",   \"exploited\": \"true\",   \"from\": \"urn:spdx.dev:vuln-cve-2023-2136\",   \"to\": [\"urn:product-google-chrome-112.0.5615.136\"],   \"suppliedBy\": [\"urn:spdx.dev:agent-jane-doe\"],   \"publishedTime\": \"2021-03-09T11:04:53Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VulnAssessmentRelationship"),("name","ExploitCatalogVulnAssessmentRelationship")], _classProperties = fromList [("catalogType",Spdx3ClassPropertyParameters {_propertyType = "ExploitCatalogType", _minCount = Just 1, _maxCount = Just 1}),("exploited",Spdx3ClassPropertyParameters {_propertyType = "xsd:boolean", _minCount = Just 1, _maxCount = Just 1}),("locator",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 1, _maxCount = Just 1})]}),("SsvcVulnAssessmentRelationship",Spdx3Class {_classSummary = "Provides an SSVC assessment for a vulnerability.", _classDescription = "An SsvcVulnAssessmentRelationship describes the decision made using the\nStakeholder-Specific Vulnerability Categorization (SSVC) decision tree\nas defined on\n<https://www.cisa.gov/stakeholder-specific-vulnerability-categorization-ssvc>.\nIt is intended to communicate the results of using the CISA SSVC\nCalculator.\n\n**Constraints**\n\n-   The relationship type must be set to hasAssessmentFor.\n\n**Syntax**\n\n`json {   \"@type\": \"SsvcVulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:ssvc-1\",   \"relationshipType\": \"hasAssessmentFor\",   \"decisionType\": \"act\",   \"from\": \"urn:spdx.dev:vuln-cve-2020-28498\",   \"to\": [\"urn:product-acme-application-1.3\"],   \"assessedElement\": \"urn:npm-elliptic-6.5.2\",   \"suppliedBy\": [\"urn:spdx.dev:agent-jane-doe\"],   \"publishedTime\": \"2021-03-09T11:04:53Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VulnAssessmentRelationship"),("name","SsvcVulnAssessmentRelationship")], _classProperties = fromList [("decisionType",Spdx3ClassPropertyParameters {_propertyType = "SsvcDecisionType", _minCount = Just 1, _maxCount = Just 1})]}),("VexAffectedVulnAssessmentRelationship",Spdx3Class {_classSummary = "Connects a vulnerability and an element designating the element as a\nproduct affected by the vulnerability.", _classDescription = "VexAffectedVulnAssessmentRelationship connects a vulnerability and a\nnumber of elements. The relationship marks these elements as products\naffected by the vulnerability. This relationship corresponds to the VEX\naffected status.\n\n**Constraints**\n\nWhen linking elements using a VexAffectedVulnAssessmentRelationship, the\nfollowing requirements must be observed:\n\n-   Elements linked with a VulnVexAffectedAssessmentRelationship are\n    constrained to the affects relationship type.\n\n**Syntax**\n\n`json {   \"@type\": \"VexAffectedVulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:vex-affected-1\",   \"relationshipType\": \"affects\",   \"from\": \"urn:spdx.dev:vuln-cve-2020-28498\",   \"to\": [\"urn:product-acme-application-1.3\"],   \"assessedElement\": \"urn:npm-elliptic-6.5.2\",   \"actionStatement\": \"Upgrade to version 1.4 of ACME application.\",   \"suppliedBy\": [\"urn:spdx.dev:agent-jane-doe\"],   \"publishedTime\": \"2021-03-09T11:04:53Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VexVulnAssessmentRelationship"),("name","VexAffectedVulnAssessmentRelationship")], _classProperties = fromList [("actionStatement",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("actionStatementTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Nothing})]}),("VexFixedVulnAssessmentRelationship",Spdx3Class {_classSummary = "Links a vulnerability and elements representing products (in the VEX\nsense) where a fix has been applied and are no longer affected.", _classDescription = "VexFixedVulnAssessmentRelationship links a vulnerability to a number of\nelements representing VEX products where a vulnerability has been fixed\nand are no longer affected. It represents the VEX fixed status.\n\n**Constraints**\n\nWhen linking elements using a VexFixedVulnAssessmentRelationship, the\nfollowing requirements must be observed:\n\n-   Elements linked with a VulnVexFixedAssessmentRelationship are\n    constrained to using the fixedIn relationship type.\n-   The from: end of the relationship must ve a /Security/Vulnerability\n    classed element.\n\n**Syntax**\n\n`json {   \"@type\": \"VexFixedVulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:vex-fixed-in-1\",   \"relationshipType\": \"fixedIn\",   \"from\": \"urn:spdx.dev:vuln-cve-2020-28498\",   \"to\": [\"urn:product-acme-application-1.3\"],   \"assessedElement\": \"urn:npm-elliptic-6.5.4\",   \"suppliedBy\": [\"urn:spdx.dev:agent-jane-doe\"],   \"publishedTime\": \"2021-03-09T11:04:53Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VexVulnAssessmentRelationship"),("name","VexFixedVulnAssessmentRelationship")], _classProperties = fromList []}),("VexNotAffectedVulnAssessmentRelationship",Spdx3Class {_classSummary = "Links a vulnerability and one or more elements designating the latter as\nproducts not affected by the vulnerability.", _classDescription = "VexNotAffectedVulnAssessmentRelationship connects a vulnerability and a\nnumber of elements designating them as products not affected by the\nvulnerability. This relationship corresponds to the VEX not\\_affected\nstatus.\n\n**Constraints**\n\nWhen linking elements using a VexNotVulnAffectedAssessmentRelationship,\nthe following requirements must be observed:\n\n-   Relating elements with a VexNotAffectedVulnAssessmentRelationship is\n    restricted to the doesNotAffect relationship type.\n-   The from: end of the relationship must be a /Security/Vulnerability\n    classed element.\n-   Both impactStatement and justificationType properties have a\n    cardinality of 0..1 making them optional. Nevertheless, to produce a\n    valid VEX not\\_affected statement, one of them MUST be defined. This\n    is specified in the Minimum Elements for VEX.\n\n**Syntax**\n\n`json {   \"@type\": \"VexNotAffectedVulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:vex-not-affected-1\",   \"relationshipType\": \"doesNotAffect\",   \"from\": \"urn:spdx.dev:vuln-cve-2020-28498\",   \"to\": [\"urn:product-acme-application-1.3\"],   \"assessedElement\": \"urn:npm-elliptic-6.5.2\",   \"justificationType\": \"componentNotPresent\",   \"impactStatement\": \"Not using this vulnerable part of this library.\",   \"suppliedBy\": [\"urn:spdx.dev:agent-jane-doe\"],   \"publishedTime\": \"2021-03-09T11:04:53Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VexVulnAssessmentRelationship"),("name","VexNotAffectedVulnAssessmentRelationship")], _classProperties = fromList [("impactStatement",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("impactStatementTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1}),("justificationType",Spdx3ClassPropertyParameters {_propertyType = "VexJustificationType", _minCount = Just 0, _maxCount = Just 1})]}),("VexUnderInvestigationVulnAssessmentRelationship",Spdx3Class {_classSummary = "Designates elements as products where the impact of a vulnerability is\nbeing investigated.", _classDescription = "VexUnderInvestigationVulnAssessmentRelationship links a vulnerability to\na number of products stating the vulnerability's impact on them is being\ninvestigated. It represents the VEX under\\_investigation status.\n\n**Constraints**\n\nWhen linking elements using a\nVexUnderInvestigationVulnAssessmentRelationship the following\nrequirements must be observed:\n\n-   Elements linked with a\n    VexUnderInvestigationVulnAssessmentRelationship are constrained to\n    using the underInvestigationFor relationship type.\n-   The from: end of the relationship must ve a /Security/Vulnerability\n    classed element.\n\n**Syntax**\n\n`json {   \"@type\": \"VexUnderInvestigationVulnAssessmentRelationship\",   \"@id\": \"urn:spdx.dev:vex-underInvestigation-1\",   \"relationshipType\": \"underInvestigationFor\",   \"from\": \"urn:spdx.dev:vuln-cve-2020-28498\",   \"to\": [\"urn:product-acme-application-1.3\"],   \"assessedElement\": \"urn:npm-elliptic-6.5.2\",   \"suppliedBy\": [\"urn:spdx.dev:agent-jane-doe\"],   \"publishedTime\": \"2021-03-09T11:04:53Z\" }`", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","VexVulnAssessmentRelationship"),("name","VexUnderInvestigationVulnAssessmentRelationship")], _classProperties = fromList []}),("VexVulnAssessmentRelationship",Spdx3Class {_classSummary = "Asbtract ancestor class for all VEX relationships", _classDescription = "VexVulnAssessmentRelationship is an abstract subclass that defined the\ncommon properties shared by all the SPDX-VEX status relationships.\n\n**Constraints**\n\nWhen linking elements using a VexVulnAssessmentRelationship, the\nfollowing requirements must be observed:\n\n-   The from: end must be a /Security/Vulnerability classed element\n-   The to: end must point to elements representing the VEX *products*.\n    To specify a different element where the vulnerability was detected,\n    the VEX relationship can optionally specify *subcomponents* using\n    the assessedElement property.\n\nVEX inherits information from the document level down to its statements.\nWhen a statement is missing information it can be completed by reading\nthe equivalent field from the containing document. For example, if a VEX\nrelationship is missing data in its createdBy property, tools must\nconsider the entity listed in the CreationInfo section of the document\nas the VEX author. In the same way, when a VEX relationship does not\nhave a created property, the document's date must be considered as\nauthoritative.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","VulnAssessmentRelationship"),("name","VexVulnAssessmentRelationship")], _classProperties = fromList [("statusNotes",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("vexVersion",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("VulnAssessmentRelationship",Spdx3Class {_classSummary = "Abstract ancestor class for all vulnerability assessments", _classDescription = "VulnAssessmentRelationship is the ancestor class common to all\nvulnerability assessment relationships. It factors out the common\nproperties shared by them.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","/Core/Relationship"),("name","VulnAssessmentRelationship")], _classProperties = fromList [("assessedElement",Spdx3ClassPropertyParameters {_propertyType = "/Core/Element", _minCount = Just 0, _maxCount = Just 1}),("modifiedTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1}),("publishedTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1}),("suppliedBy",Spdx3ClassPropertyParameters {_propertyType = "/Core/Agent", _minCount = Just 0, _maxCount = Just 1}),("withdrawnTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1})]}),("Vulnerability",Spdx3Class {_classSummary = "Specifies a vulnerability and its associated information.", _classDescription = "Specifies a vulnerability and its associated information.\n\n**Syntax**\n\n`` json {   \"@type\": \"Vulnerability\",   \"@id\": \"urn:spdx.dev:vuln-1\",   \"summary\": \"Use of a Broken or Risky Cryptographic Algorithm\",   \"description\": \"The npm package `elliptic` before version 6.5.4 are vulnerable to Cryptographic Issues via the secp256k1 implementation in elliptic/ec/key.js. There is no check to confirm that the public key point passed into the derive function actually exists on the secp256k1 curve. This results in the potential for the private key used in this implementation to be revealed after a number of ECDH operations are performed.\",         \"modified\": \"2021-03-08T16:02:43Z\",   \"published\": \"2021-03-08T16:06:50Z\",   \"externalIdentifiers\": [     {       \"@type\": \"ExternalIdentifier\",       \"externalIdentifierType\": \"cve\",       \"identifier\": \"CVE-2020-2849\",       \"identifierLocator\": [         \"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-28498\",         \"https://www.cve.org/CVERecord?id=CVE-2020-28498\"       ],       \"issuingAuthority\": \"urn:spdx.dev:agent-cve.org\"     },     {       \"type\": \"ExternalIdentifier\",       \"externalIdentifierType\": \"securityOther\",       \"identifier\": \"GHSA-r9p9-mrjm-926w\",       \"identifierLocator\": \"https://github.com/advisories/GHSA-r9p9-mrjm-926w\"     },     {       \"type\": \"ExternalIdentifier\",       \"externalIdentifierType\": \"securityOther\",       \"identifier\": \"SNYK-JS-ELLIPTIC-1064899\",       \"identifierLocator\": \"https://security.snyk.io/vuln/SNYK-JS-ELLIPTIC-1064899\"     }   ],   \"externalReferences\": [     {         \"@type\": \"ExternalReference\",         \"externalReferenceType\": \"securityAdvisory\",         \"locator\": \"https://nvd.nist.gov/vuln/detail/CVE-2020-28498\"     },     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityAdvisory\",       \"locator\": \"https://ubuntu.com/security/CVE-2020-28498\"     },     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityOther\",       \"locator\": \"https://github.com/indutny/elliptic/pull/244/commits\"     },     {       \"@type\": \"ExternalReference\",       \"externalReferenceType\": \"securityOther\",       \"locator\": \"https://github.com/christianlundkvist/blog/blob/master/2020_05_26_secp256k1_twist_attacks/secp256k1_twist_attacks.md\"     }   ] }, {   \"@type\": \"Relationship\",   \"@id\": \"urn:spdx.dev:vulnRelationship-1\",   \"relationshipType\": \"hasAssociatedVulnerability\",   \"from\": \"urn:npm-elliptic-6.5.2\",   \"to\": [\"urn:spdx.dev:vuln-1\"],   \"startTime\": \"2021-03-08T16:06:50Z\" }, {   \"@type\": \"Relationship\",   \"@id\": \"urn:spdx.dev:vulnAgentRel-1\",     \"relationshipType\": \"publishedBy\",     \"from\": \"urn:spdx.dev:vuln-1\",   \"to\": [\"urn:spdx.dev:agent-snyk\"],   \"startTime\": \"2021-03-08T16:06:50Z\" } ``", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","/Core/Element"),("name","Vulnerability")], _classProperties = fromList [("modifiedTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1}),("publishedTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1}),("withdrawnTime",Spdx3ClassPropertyParameters {_propertyType = "/Core/DateTime", _minCount = Just 0, _maxCount = Just 1})]})]}),("Software",Spdx3Profile {_profileSummary = "Everything having to do with software.", _profileDescription = "The Software namespace defines concepts related to software artifacts.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3/Software"),("name","Software")], _profileProperties = fromList [("additionalPurpose",Spdx3Property {_propertySummary = "Provides additional purpose information of the software artifact.", _propertyDescription = "Additional purpose provides information about the additional purposes of\nthe software artifact in addition to the primaryPurpose.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SoftwarePurpose"),("name","additionalPurpose")]}),("attributionText",Spdx3Property {_propertySummary = "Provides a place for the SPDX data creator to record acknowledgement\ntext for a software Package, File or Snippet.", _propertyDescription = "An attributionText for a software Package, File or Snippet provides a\nconsumer of SPDX data with acknowledgement content, to assist\nredistributors of the Package, File or Snippet with reproducing those\nacknowledgements.\n\nFor example, this field may include a statement that is required by a\nparticular license to be reproduced in end-user documentation,\nadvertising materials, or another form.\n\nThis field may describe where, or in which contexts, the\nacknowledgements need to be reproduced, but it is not required to do so.\nThe SPDX data creator may also explain elsewhere (such as in a\nlicenseComment field) how they intend for data in this field to be used.\n\nAn attributionText is is not meant to include the software Package, File\nor Snippet\8217s actual complete license text (see concludedLicense to\nidentify the corresponding license).", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","attributionText")]}),("byteRange",Spdx3Property {_propertySummary = "Defines the byte range in the original host file that the snippet\ninformation applies to.", _propertyDescription = "This field defines the byte range in the original host file that the\nsnippet information applies to. A range of bytes is independent of\nvarious formatting concerns, and the most accurate way of referring to\nthe differences. The choice was made to start the numbering of the byte\nrange at 1 to be consistent with the W3C pointer method vocabulary.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/PositiveIntegerRange"),("name","byteRange")]}),("concludedLicense",Spdx3Property {_propertySummary = "Identifies the license that that SPDX data creator has concluded as\ngoverning the software Package, File or Snippet.", _propertyDescription = "A concludedLicense is the license identified by the SPDX data creator,\nbased on analyzing the license information in the software Package, File\nor Snippet and other information to arrive at a reasonably objective\nconclusion as to what license governs it.\n\nIf a concludedLicense has a NONE value (NoneLicense), this indicates\nthat the SPDX data creator has looked and did not find any license\ninformation for this software Package, File or Snippet.\n\nIf a concludedLicense has a NOASSERTION value (NoAssertionLicense), this\nindicates that one of the following applies: \\* the SPDX data creator\nhas attempted to but cannot reach a reasonable objective determination;\n\\* the SPDX data creator has made no attempt to determine this field; or\n\\* the SPDX data creator has intentionally provided no information (no\nmeaning should be implied by doing so).\n\nA written explanation of a NOASSERTION value (NoAssertionLicense) MAY be\nprovided in the licenseComment field.\n\nIf the concludedLicense for a software Package, File or Snippet is not\nthe same as its declaredLicense, a written explanation SHOULD be\nprovided in the licenseComment field.\n\nIf the declaredLicense for a software Package, File or Snippet is a\nchoice of more than one license (e.g. a license expression combining two\nlicenses through use of the `OR` operator), then the concludedLicense\nmay either retain the license choice or identify which license was\nchosen.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","/Licensing/LicenseField"),("name","concludedLicense")]}),("conditionality",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A conditionality is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DependencyConditionalityType"),("name","conditionality")]}),("contentIdentifier",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A contentIdentifier is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","contentIdentifier")]}),("contentType",Spdx3Property {_propertySummary = "Provides information about the content type of an Element.", _propertyDescription = "This field is a reasonable estimation of the content type of the\nElement, from a creator perspective. Content type is intrinsic to the\nElement, independent of how the Element is being used.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/MediaType"),("name","contentType")]}),("copyrightText",Spdx3Property {_propertySummary = "Identifies the text of one or more copyright notices for a software\nPackage, File or Snippet, if any.", _propertyDescription = "A copyrightText consists of the text(s) of the copyright notice(s) found\nfor a software Package, File or Snippet, if any.\n\nIf a copyrightText contains text, then it may contain any text related\nto one or more copyright notices (even if not complete) for that\nsoftware Package, File or Snippet.\n\nIf a copyrightText has a \"NONE\" value, this indicates that the software\nPackage, File or Snippet contains no copyright notice whatsoever.\n\nIf a copyrightText has a \"NOASSERTION\" value, this indicates that one of\nthe following applies: \\* the SPDX data creator has attempted to but\ncannot reach a reasonable objective determination; \\* the SPDX data\ncreator has made no attempt to determine this field; or \\* the SPDX data\ncreator has intentionally provided no information (no meaning should be\nimplied by doing so).", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","xsd:string"),("name","copyrightText")]}),("declaredLicense",Spdx3Property {_propertySummary = "Identifies the license information actually found in the software\nPackage, File or Snippet, for example as detected by use of automated\ntooling.", _propertyDescription = "A declaredLicense is the license identified in text in the software\npackage, file or snippet as the license declared by its authors.\n\nThis field is not intended to capture license information obtained from\nan external source, such as a package's website. Such information can be\nincluded, as needed, in a concludedLicense field.\n\nA declaredLicense may be expressed differently in practice for different\ntypes of artifacts. For example:\n\n-   for Packages:\n    -   would include license info describing the license of the Package\n        as a whole, when it is found in the Package itself (e.g.,\n        LICENSE file, README file, metadata in the repository, etc.)\n    -   would not include any license information that is not in the\n        Package itself (e.g., license information from the project\8217s\n        website or from a third party repository or website)\n-   for Files:\n    -   would include license info found in the File itself (e.g.,\n        license header or notice, comments, SPDX-License-Identifier\n        expression)\n    -   would not include license info found in a different file (e.g.,\n        LICENSE file in the top directory of a repository)\n-   for Snippets:\n    -   would include license info found in the Snippet itself (e.g.,\n        license notice, comments, SPDX-License-Identifier expression)\n    -   would not include license info found elsewhere in the File or in\n        a different File (e.g., comment at top of File if it is not\n        within the Snippet, LICENSE file in the top directory of a\n        repository)\n\nIf a declaredLicense has a NONE value (NoneLicense), this indicates that\nthe corresponding Package, File or Snippet contains no license\ninformation whatsoever.\n\nIf a declaredLicense has a NOASSERTION value (NoAssertionLicense), this\nindicates that one of the following applies: \\* the SPDX data creator\nhas attempted to but cannot reach a reasonable objective determination;\n\\* the SPDX data creator has made no attempt to determine this field; or\n\\* the SPDX data creator has intentionally provided no information (no\nmeaning should be implied by doing so).", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","/Licensing/LicenseField"),("name","declaredLicense")]}),("downloadLocation",Spdx3Property {_propertySummary = "Identifies the download Uniform Resource Identifier for the package at\nthe time that the document was created.", _propertyDescription = "DownloadLocation identifies the download Uniform Resource Identifier for\nthe package at the time that the document was created. Where and how to\ndownload the exact package being referenced is critical for verification\nand tracking data.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","downloadLocation")]}),("homePage",Spdx3Property {_propertySummary = "A place for the SPDX document creator to record a website that serves as\nthe package's home page.", _propertyDescription = "HomePage is a place for the SPDX document creator to record a website\nthat serves as the package's home page. This saves the recipient of the\nSPDX document who is looking for more info from having to search for and\nverify a match between the package and the associated project home page.\nThis link can also be used to reference further information about the\npackage referenced by the SPDX document creator.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","homePage")]}),("lineRange",Spdx3Property {_propertySummary = "Defines the line range in the original host file that the snippet\ninformation applies to.", _propertyDescription = "This field defines the line range in the original host file that the\nsnippet information applies to. If there is a disagreement between the\nbyte range and line range, the byte range values will take precedence. A\nrange of lines is a convenient reference for those files where there is\na known line delimiter. The choice was made to start the numbering of\nthe lines at 1 to be consistent with the W3C pointer method vocabulary.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","/Core/PositiveIntegerRange"),("name","lineRange")]}),("packageUrl",Spdx3Property {_propertySummary = "Provides a place for the SPDX data creator to record the package URL\nstring (in accordance with the [package URL\nspec](https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst))\nfor a software Package.", _propertyDescription = "A packageUrl (commonly pronounced and referred to as \"purl\") is an\nattempt to standardize package representations in order to reliably\nidentify and locate software packages. A purl is a URL string which\nrepresents a package in a mostly universal and uniform way across\nprogramming languages, package managers, packaging conventions, tools,\nAPIs and databases.\n\nthe purl URL string is defined by seven components:\n`scheme:type/namespace/name@version?qualifiers#subpath`\n\nThe definition for each component can be found in the [purl\nspecification](https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst).\nComponents are designed such that they form a hierarchy from the most\nsignificant on the left to the least significant components on the\nright.\n\nParsing a purl string into its components works from left to right. Some\nextra type-specific normalizations are required. For more information,\nsee [How to parse a purl string in its\ncomponents](https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst#how-to-parse-a-purl-string-in-its-components).", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:anyURI"),("name","packageUrl")]}),("packageVersion",Spdx3Property {_propertySummary = "Identify the version of a package.", _propertyDescription = "A packageVersion is useful for identification purposes and for\nindicating later changes of the package version.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","packageVersion")]}),("primaryPurpose",Spdx3Property {_propertySummary = "Provides information about the primary purpose of the software artifact.", _propertyDescription = "primaryPurpose provides information about the primary purpose of the\nsoftware artifact.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SoftwarePurpose"),("name","primaryPurpose")]}),("sbomType",Spdx3Property {_propertySummary = "Provides information about the type of an SBOM.", _propertyDescription = "This field is a reasonable estimation of the type of SBOM created from a\ncreator perspective. It is intended to be used to give guidance on the\nelements that may be contained within it. Aligning with the guidance\nproduced in [Types of Software Bill of Material (SBOM)\nDocuments](https://www.cisa.gov/sites/default/files/2023-04/sbom-types-document-508c.pdf).", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SBOMType"),("name","sbomType")]}),("softwareLinkage",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A softwareLinkage is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SoftwareDependencyLinkType"),("name","softwareLinkage")]}),("sourceInfo",Spdx3Property {_propertySummary = "Records any relevant background information or additional comments about\nthe origin of the package.", _propertyDescription = "SourceInfo records any relevant background information or additional\ncomments about the origin of the package. For example, this field might\ninclude comments indicating whether the package was pulled from a source\ncode management system or has been repackaged. The creator can provide\nadditional information to describe any anomalies or discoveries in the\ndetermination of the origin of the package.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","sourceInfo")]})], _profileVocabularies = fromList [("DependencyConditionalityType",Spdx3Vocabulary {_vocabularySummary = "TODO", _vocabularyDescription = "TODO", _vocabularyMetadata = fromList [("name","DependencyConditionalityType")], _vocabularyEntries = fromList [("optional","TODOdescription"),("other","TODOdescription"),("prerequisite","TODOdescription"),("provided","TODOdescription"),("required","TODOdescription")]}),("SBOMType",Spdx3Vocabulary {_vocabularySummary = "Provides a set of values to be used to describe the common types of\nSBOMs that tools may create.", _vocabularyDescription = "The set of SBOM types with definitions as defined in [Types of Software\nBill of Material (SBOM)\nDocuments](https://www.cisa.gov/sites/default/files/2023-04/sbom-types-document-508c.pdf),\npublished on April 21, 2023. An SBOM type describes the most likely type\nof an SBOM from the producer perspective, so that consumers can draw\nconclusions about the data inside an SBOM. A single SBOM can have\nmultiple SBOM document types associated with it.", _vocabularyMetadata = fromList [("name","SBOMType")], _vocabularyEntries = fromList [("analyzed","SBOM generated through analysis of artifacts (e.g., executables,\npackages, containers, and virtual machine images) after its build. Such\nanalysis generally requires a variety of heuristics. In some contexts,\nthis may also be referred to as a \8220\&3rd party\8221 SBOM."),("build","SBOM generated as part of the process of building the software to create\na releasable artifact (e.g., executable or package) from data such as\nsource files, dependencies, built components, build process ephemeral\ndata, and other SBOMs."),("deployed","SBOM provides an inventory of software that is present on a system. This\nmay be an assembly of other SBOMs that combines analysis of\nconfiguration options, and examination of execution behavior in a\n(potentially simulated) deployment environment."),("design","SBOM of intended, planned software project or product with included\ncomponents (some of which may not yet exist) for a new software\nartifact."),("runtime","SBOM generated through instrumenting the system running the software, to\ncapture only components present in the system, as well as external\ncall-outs or dynamically loaded components. In some contexts, this may\nalso be referred to as an \8220Instrumented\8221 or \8220Dynamic\8221 SBOM."),("source","SBOM created directly from the development environment, source files,\nand included dependencies used to build an product artifact.")]}),("SoftwareDependencyLinkType",Spdx3Vocabulary {_vocabularySummary = "TODO", _vocabularyDescription = "TODO", _vocabularyMetadata = fromList [("name","SoftwareDependencyLinkType")], _vocabularyEntries = fromList [("dynamic","TODOdescription"),("other","TODOdescription"),("static","TODOdescription"),("tool","TODOdescription")]}),("SoftwarePurpose",Spdx3Vocabulary {_vocabularySummary = "Provides information about the primary purpose of an Element.", _vocabularyDescription = "This field provides information about the primary purpose of an Element.\nSoftware Purpose is intrinsic to how the Element is being used rather\nthan the content of the Element. This field is a reasonable estimate of\nthe most likely usage of the Element from the producer and consumer\nperspective from which both parties can draw conclusions about the\ncontext in which the Element exists.", _vocabularyMetadata = fromList [("name","SoftwarePurpose")], _vocabularyEntries = fromList [("application","the Element is a software application"),("archive","the Element is an archived collection of one or more files (.tar, .zip,\netc)"),("bom","Element is a bill of materials"),("configuration","Element is configuration data"),("container","the Element is a container image which can be used by a container\nruntime application"),("data","Element is data"),("device","the Element refers to a chipset, processor, or electronic board"),("documentation","Element is documentation"),("evidence","the Element is the evidence that a specification or requirement has been\nfulfilled"),("executable","Element is an Artifact that can be run on a computer"),("file","the Element is a single file which can be independently distributed\n(configuration file, statically linked binary, Kubernetes deployment,\netc)"),("firmware","the Element provides low level control over a device's hardware"),("framework","the Element is a software framework"),("install","the Element is used to install software on disk"),("library","the Element is a software library"),("manifest","the Element is a software manifest"),("mlModel","the Element is a machine learning model"),("module","the Element is a module of a piece of software"),("operatingSystem","the Element is an operating system"),("other","the Element doesn't fit into any of the other categories"),("patch","Element contains a set of changes to update, fix, or improve another\nElement"),("requirement","the Element provides a requirement needed as input for another Element"),("source","the Element is a single or a collection of source files"),("specification","the Element is a plan, guideline or strategy how to create, perform or\nanalyse an application")]})], _profileClasses = fromList [("File",Spdx3Class {_classSummary = "Refers to any object that stores content on a computer.", _classDescription = "Refers to any object that stores content on a computer. The type of\ncontent can optionally be provided in the contentType property.", _classMetadata = fromList [("SubclassOf","/Software/SoftwareArtifact"),("name","File")], _classProperties = fromList [("contentType",Spdx3ClassPropertyParameters {_propertyType = "/Core/MediaType", _minCount = Just 0, _maxCount = Just 1})]}),("Package",Spdx3Class {_classSummary = "Refers to any unit of content that can be associated with a distribution\nof software.", _classDescription = "A package refers to any unit of content that can be associated with a\ndistribution of software. Typically, a package is composed of one or\nmore files.  \nAny of the following non-limiting examples may be (but are not required\nto be) represented in SPDX as a package:\n\n-   a tarball, zip file or other archive\n-   a directory or sub-directory\n-   a separately distributed piece of software which another Package or\n    File uses or depends upon (e.g., a Python package, a Go module, ...)\n-   a container image, and/or each image layer within a container image\n-   a collection of one or more sub-packages\n-   a Git repository snapshot from a particular point in time\n\nNote that some of these could be represented in SPDX as a file as well.", _classMetadata = fromList [("SubclassOf","/Software/SoftwareArtifact"),("name","Package")], _classProperties = fromList [("downloadLocation",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Just 1}),("homePage",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Just 1}),("packageUrl",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Just 1}),("packageVersion",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("sourceInfo",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("Sbom",Spdx3Class {_classSummary = "A collection of SPDX Elements describing a single package.", _classDescription = "A Software Bill of Materials (SBOM) is a collection of SPDX Elements\ndescribing a single package. This could include details of the content\nand composition of the product, provenance details of the product and/or\nits composition, licensing information, known quality or security\nissues, etc.", _classMetadata = fromList [("SubclassOf","/Core/Bom"),("name","Sbom")], _classProperties = fromList [("sbomType",Spdx3ClassPropertyParameters {_propertyType = "SBOMType", _minCount = Just 0, _maxCount = Nothing})]}),("Snippet",Spdx3Class {_classSummary = "Describes a certain part of a file.", _classDescription = "A Snippet describes a certain part of a file and can be used when the\nfile is known to have some content that has been included from another\noriginal source. Snippets are useful for denoting when part of a file\nmay have been originally created under another license or copied from a\nplace with a known vulnerability.", _classMetadata = fromList [("SubclassOf","/Software/SoftwareArtifact"),("name","Snippet")], _classProperties = fromList [("byteRange",Spdx3ClassPropertyParameters {_propertyType = "/Core/PositiveIntegerRange", _minCount = Just 0, _maxCount = Just 1}),("lineRange",Spdx3ClassPropertyParameters {_propertyType = "/Core/PositiveIntegerRange", _minCount = Just 0, _maxCount = Just 1})]}),("SoftwareArtifact",Spdx3Class {_classSummary = "A distinct article or unit related to Software.", _classDescription = "A software artifact is a distinct article or unit related to software\nsuch as a package, a file, or a snippet.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","/Core/Artifact"),("name","SoftwareArtifact")], _classProperties = fromList [("additionalPurpose",Spdx3ClassPropertyParameters {_propertyType = "SoftwarePurpose", _minCount = Just 0, _maxCount = Nothing}),("attributionText",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("concludedLicense",Spdx3ClassPropertyParameters {_propertyType = "/Licensing/LicenseField", _minCount = Just 0, _maxCount = Just 1}),("contentIdentifier",Spdx3ClassPropertyParameters {_propertyType = "xsd:anyURI", _minCount = Just 0, _maxCount = Just 1}),("copyrightText",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("declaredLicense",Spdx3ClassPropertyParameters {_propertyType = "/Licensing/LicenseField", _minCount = Just 0, _maxCount = Just 1}),("primaryPurpose",Spdx3ClassPropertyParameters {_propertyType = "SoftwarePurpose", _minCount = Just 0, _maxCount = Just 1})]}),("SoftwareDependencyRelationship",Spdx3Class {_classSummary = "MISSING", _classDescription = "TODO", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","/Core/LifecycleScopedRelationship"),("name","SoftwareDependencyRelationship")], _classProperties = fromList [("conditionality",Spdx3ClassPropertyParameters {_propertyType = "DependencyConditionalityType", _minCount = Just 0, _maxCount = Just 1}),("softwareLinkage",Spdx3ClassPropertyParameters {_propertyType = "SoftwareDependencyLinkType", _minCount = Just 0, _maxCount = Just 1})]})]})]}