Spdx3Model {_profiles = fromList [("AI",Spdx3Profile {_profileSummary = "Additional metadata based on software profile, that is useful for ai\napplications and models.", _profileDescription = "The AI profile namespace defines concepts related to AI application and\nmodel artifacts.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3#AI"),("name","AI")], _profileProperties = fromList [("autonomyType",Spdx3Property {_propertySummary = "Field captures if a human is in the in the loop", _propertyDescription = "It is a field of presence type that indicates if a human is in the loop\nin the AI software for any of the decisions or if it's fully automatic.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","PresenceType"),("name","autonomyType")]}),("dataPreprocessingSteps",Spdx3Property {_propertySummary = "Field captures Capture all the preprocessing steps done before the model\ntraining", _propertyDescription = "This is a free form text field that describes the preprocessing steps\ndone to the data before training the model(s) contained in the AI\nsoftware", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","dataPreprocessingSteps")]}),("energyConsumption",Spdx3Property {_propertySummary = "Field captures the amount of energy consumed to build this AI package", _propertyDescription = "Text field that captures the energy consumption during training and\noperation of the AI model. a.k.a training energy consumption, inference\nenergy consumption", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","energyConsumption")]}),("hyperparameters",Spdx3Property {_propertySummary = "Field captures the record of the hyperparameters used to build the AI\nmodel contained in the AI package", _propertyDescription = "The field records all or the important hyperparameters of each model.\nThe hyperparmeters are listed as\nhyperparameter1*name:hyperparameter1*value, hyperparameter2*name:\nhyperparameter2*value etc. If there are multiple models, the\nhyperparameters of each model are listed in a separate line.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","hyperparameters")]}),("informationAboutApplication",Spdx3Property {_propertySummary = "Field describe the features used and other relevant information about\nthe AI software in addition to the model.", _propertyDescription = "A text field that describes any relevant information in free form about\nhow the AI model is used inside the software, any relevant\npre-processing steps, third party APIs etc.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","informationAboutApplication")]}),("informationAboutTraining",Spdx3Property {_propertySummary = "Field describe the features used and other relevant information about\ndifferent steps of training", _propertyDescription = "This is a text field that describes in detail about the specific steps\ninvolved during the training of the AI model in free form text. For\nexample, if supervised fine tuning is used, or in active learning is\nused as a part of training the model that is being used in the AI\nsoftware.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","informationAboutTraining")]}),("limitations",Spdx3Property {_propertySummary = "Field captures any limitations of the AI Package (the AI models\ncontained) one wishes to note down.", _propertyDescription = "Text field that captures the limitations of the AI software. The\nlimitations are expressed as free form text.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","limitations")]}),("metrics",Spdx3Property {_propertySummary = "This field records the measurement of prediction quality including\nuncertainty, accuracy, characteristics of of tested population, Quality,\nFairness, explainability, Robustness etc", _propertyDescription = "The field describes the metrics used to evaluate the AI model used in\nthe AI software. Its a text field where metrics are listed in a comma\nseparated fashion in the following format metric*1: value,\nmetric*2:value, etc. If there are multiple models, metrics are listed in\na new line for each model.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","metrics")]}),("metricsDecisionThresholds",Spdx3Property {_propertySummary = "Field captures the thresholds that are being used for metric computation\nof the metrics described in the metrics field. Should match with the\nMetrics field and depends on the metrics field", _propertyDescription = "Each metric might be computed based on a decision threshold (for\ninstance precision or recall is typically computed by splitting checking\nif the probability of the outcome is &gt;0.5). This field records the\ndecision threshold in comma separated values. E.g.,\nmetric*1:decsion*threshold, metric\\_2:decision threshold. If there are\nmultiple models each line represents each model\8217s metrics and decision\nthreshold.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","metricsDecisionThresholds")]}),("modelExplainabilityMechanisms",Spdx3Property {_propertySummary = "Field captures methods that can be used to explain the model", _propertyDescription = "This is a free form text field that lists the different explainability\nmechanisms (such a SHAP, or other model specific explainability\nmechanisms) that can be used to explain the model in a comma separated\nfashion.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","modelExplainabilityMechanisms")]}),("safetyRiskAssessmentType",Spdx3Property {_propertySummary = "Field categorizes safety risk impact of AI software in the terms of\nSerious, high, medium low", _propertyDescription = "It is a field of type safeRiskAssessment and the possible values are\nserious, high, medium, low. These risk types are defined in accordance\nwith Article 20 of EC Regulation  \nNo 765/2008.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SafetyRiskAssessmentType"),("name","safetyRiskAssessment")]}),("sensitivePersonalInformationType",Spdx3Property {_propertySummary = "Field records if sensitive personal information is used in model\ntraining", _propertyDescription = "This field notes if sensitive personal information like biometric data,\naddress or other personally identifiable data is used in the training or\ninference of the AI models. The possible values are \8216yes\8217, \8216no\8217 and\n\8216noassertion\8217.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SensitivePersonalInformationType"),("name","PresenceType")]}),("standardsCompliance",Spdx3Property {_propertySummary = "Field captures What laws and regulations are being adhered to.", _propertyDescription = "Text field that captures the list of standards that the AI software\ncomplies with. This could include both published and unpublished\nstandards including ISO, IEEE, ETSI standards. Each standard is listed\non a separate line or in a single line with each standard being comma\nseparated.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","standardsCompliance")]}),("typeOfModel",Spdx3Property {_propertySummary = "Field records the type of the model used in the AI software.", _propertyDescription = "This is a text field that records the type of the AI model(s) used in\nthe software. For instance if its supervised model, unsupervised model\nor if its a reinforcement learning model or a combination. Preferably\nexpressed using AND conjugation if there are multiple models being used\nas a part of the AI software.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","typeOfModel")]})], _profileVocabularies = fromList [("SafetyRiskAssessmentType",Spdx3Vocabulary {_vocabularySummary = "Categories of safety risk impact of application ie. Serious, high,\nmedium low", _vocabularyDescription = "Describes the different safety risk type values that can be used to\ndescribe the safety risk of the AI software", _vocabularyMetadata = fromList [("name","SafetyRiskAssessmentType")], _vocabularyEntries = fromList [("high","The second highest level of risk posed by the AI software as given by\nArticle 20 of EC Regulation No 765/2008."),("low","Low/no risk is contained in the AI software."),("medium","The third highest level of risk as given by Article 20 of EC\nRegulation  \nNo 765/2008."),("serious","The highest level of risk that is contained for a AI software as given\nby Article 20 of Regulation 765/2008/EC")]}),("SensitivePersonalInformationType",Spdx3Vocabulary {_vocabularySummary = "Categories of presence or absence", _vocabularyDescription = "This type is used to indicate if a given field is present or absent or\nunknown", _vocabularyMetadata = fromList [("name","SensitivePersonalInformationType")], _vocabularyEntries = fromList [("no","Indicates absence of the field"),("noassertion","Describes no assertion. In other words, unknown."),("yes","Indicates presence of the field")]})], _profileClasses = fromList [("AIPackage",Spdx3Class {_classSummary = "MISSING", _classDescription = "Metadata information that can be added to a package to describe an AI\napplication or trained AI model.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Software:Package"),("name","AIPackage")], _classProperties = fromList [("autonomyType",Spdx3ClassPropertyParameters {_propertyType = "PresenceType", _minCount = Just 0, _maxCount = Just 1}),("dataPreprocessingSteps",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("domain",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("energyConsumption",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("hyperparameters",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("informationAboutApplication",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("informationAboutTraining",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("limitations",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("metrics",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("metricsDecisionThresholds",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("modelExplainabilityMechanisms",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("safetyRiskAssessment",Spdx3ClassPropertyParameters {_propertyType = "SafetyRiskAssessmentType", _minCount = Just 0, _maxCount = Just 1}),("sensitivePersonalInformation",Spdx3ClassPropertyParameters {_propertyType = "SensitivePersonalInformationType", _minCount = Just 0, _maxCount = Just 1}),("standardsCompliance",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("typeOfModel",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing})]})]}),("Build",Spdx3Profile {_profileSummary = "Everything having to do with the build profile.", _profileDescription = "The Build namespace defines concepts related to building of artifacts.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3#Build"),("name","Build")], _profileProperties = fromList [("buildId",Spdx3Property {_propertySummary = "A buildId is a locally unique identifier used by a builder to identify a\nunique instance of a build produced by it.", _propertyDescription = "A buildId is a locally unique identifier to identify a unique instance\nof a build.This identifier differs based on build toolchain, platform,\nor naming convention used by an organization or standard.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","string"),("name","buildId")]}),("buildType",Spdx3Property {_propertySummary = "A buildType is a hint that is used to indicate the toolchain, platform,\nor infrastructure that the build was invoked on.", _propertyDescription = "A buildType is a URI expressing the toolchain, platform, or\ninfrastructure that the build was invoked on. For example, if the build\nwas invoked on GitHub's CI platform using github actions, the buildType\ncan be expressed as `https://github.com/actions`. In contrast, if the\nbuild was invoked on a local machine, the buildType can be expressed as\n`file://username@host/path/to/build`.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","buildId")]}),("configSourceDigest",Spdx3Property {_propertySummary = "Property that describes the digest of the build configuration file used\nto invoke a build.", _propertyDescription = "configSourceDigest is the checksum of the build configuration file used\nby a builder to execute a build. This Property uses the Core model's\n[Hash](../../Core/Classes/Hash.md) class.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","Hash"),("name","configSourceDigest")]}),("configSourceEntrypoint",Spdx3Property {_propertySummary = "Property describes the invocation entrypoint of a build.", _propertyDescription = "A build entrypoint is the invoked executable of a build which always\nruns when the build is triggered. For example, when a build is triggered\nby running a shell script, the entrypoint is `script.sh`. In terms of a\ndeclared build, the entrypoint is the position in a configuration file\nor a build declaration which is always run when the build is triggered.\nFor example, in the following configuration file:\n\n\\`\\`\\` name: Publish packages to PyPI\n\non: create: tags: \"\\*\"\n\njobs: publish: runs-on: ubuntu-latest if: startsWith(github.ref,\n'refs/tags/') steps:\n\n... \\`\\`\\`\n\nThe entrypoint of the build is `publish`.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","string"),("name","configSourceEntrypoint")]}),("configSourceUri",Spdx3Property {_propertySummary = "Property that describes the URI of the build configuration source file.", _propertyDescription = "The configSourceUri of a build is the URI of the build configuration, if\nexisting, used by a toolchain or platform. For example, a build\ntriggered by a github action has a configSourceUri as the URL of the\nYAML file for the GitHub repository.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","configSourceUri")]}),("endTime",Spdx3Property {_propertySummary = "Property that describes the time at which a build stops.", _propertyDescription = "endTime describes the time at which a build stops or finishes. This\nvalue is typically recorded by the builder.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DateTime"),("name","endTime")]}),("environment",Spdx3Property {_propertySummary = "Property describing the session in which a build is invoked.", _propertyDescription = "environment is a map of environment variables and values that are set\nduring a build session. This is different from the\n[parameters](parameters.md) property in that it describes the\nenvironment variables set before a build is invoked rather than the\nvariables provided to the builder.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","map&lt;string&gt;string"),("name","environment")]}),("parameters",Spdx3Property {_propertySummary = "Property describing the parameters used in an instance of a build.", _propertyDescription = "parameters is a key-value map of all build parameters and their values\nthat were provided to the builder for a build instance. This is\ndifferent from [environment](environment.md) property in that the keys\nand values are provided as command line arguments or a configuration\nfile to the builder.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","map&lt;string&gt;string"),("name","parameters")]}),("startTime",Spdx3Property {_propertySummary = "Property describing the start time of a build.", _propertyDescription = "startTime is the time at which a build is triggered. The builder\ntypically records this value.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","DateTime"),("name","startTime")]})], _profileVocabularies = fromList [("BuildTypeVocab",Spdx3Vocabulary {_vocabularySummary = "MISSING", _vocabularyDescription = "This is about the vocabulary of build types.", _vocabularyMetadata = fromList [("Type","URI"),("name","BuildTypeVocab")], _vocabularyEntries = fromList []})], _profileClasses = fromList [("Build",Spdx3Class {_classSummary = "Class that describes a build instance of software/artifacts.", _classDescription = "A build is a representation of the process in which a piece of software\nor artifact is built. It encapsulates information related to a build\nprocess and provides an element from which relationships can be created\nto describe the build's inputs, outputs, and related entities (e.g.\nbuilders, identities, etc.).\n\nDefinitions of \"BuildType\", \"ConfigSource\", \"Parameters\" and\n\"Environment\" follow those defined in [SLSA\nprovenance](https://slsa.dev/provenance/v0.2).\n\nExternalIdentifier of type \"urlScheme\" may be used to identify build\nlogs. Comment should be \"LogReference\".", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Core:Element"),("name","Build")], _classProperties = fromList [("buildId",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("buildType",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 1, _maxCount = Just 1}),("configSourceDigest",Spdx3ClassPropertyParameters {_propertyType = "Hash", _minCount = Just 0, _maxCount = Nothing}),("configSourceEntrypoint",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Nothing}),("configSourceUri",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 0, _maxCount = Nothing}),("endTime",Spdx3ClassPropertyParameters {_propertyType = "xsd:DateTime", _minCount = Nothing, _maxCount = Nothing}),("environment",Spdx3ClassPropertyParameters {_propertyType = "xsd:map&lt;string&gt;string", _minCount = Just 0, _maxCount = Nothing}),("parameters",Spdx3ClassPropertyParameters {_propertyType = "xsd:map&lt;string&gt;string", _minCount = Just 0, _maxCount = Nothing}),("startTime",Spdx3ClassPropertyParameters {_propertyType = "xsd:DateTime", _minCount = Nothing, _maxCount = Nothing})]})]}),("Core",Spdx3Profile {_profileSummary = "The basis for all SPDX profiles.", _profileDescription = "The Core namespace defines foundational concepts serving as the basis\nfor all SPDX-3.0 profiles.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3#Core"),("name","Core")], _profileProperties = fromList [("algorithm",Spdx3Property {_propertySummary = "Specifies the algorithm used for calculating the hash value.", _propertyDescription = "An algorithm specifies the algorithm that was used for calculating the\nhash value.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","HashAlgorithm"),("name","algorithm")]}),("annotationType",Spdx3Property {_propertySummary = "Describes the type of annotation.", _propertyDescription = "An annotationType describes the type of an annotation.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","AnnotationType"),("name","annotationType")]}),("comment",Spdx3Property {_propertySummary = "Provide consumers with comments by the creator of the Element about the\nElement.", _propertyDescription = "A comment is an optional field for creators of the Element to provide\ncomments to the readers/reviewers of the document.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","comment")]}),("completeness",Spdx3Property {_propertySummary = "Provides information about the completeness of relationships.", _propertyDescription = "Completeness gives information about whether the provided relationships\nare complete, known to be incomplete or if no assertion is made either\nway.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","RelationshipCompleteness"),("name","completeness")]}),("contentType",Spdx3Property {_propertySummary = "Specifies the media type of an Element.", _propertyDescription = "ContentType specifies the media type of an Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","MediaType"),("name","contentType")]}),("context",Spdx3Property {_propertySummary = "Gives information about the circumstances or unifying properties that\nElements of the bundle have been assembled under.", _propertyDescription = "A context gives information about the circumstances or unifying\nproperties that Elements of the bundle have been assembled under.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","context")]}),("created",Spdx3Property {_propertySummary = "Identifies when the Element was originally created.", _propertyDescription = "Created is a date that identifies when the Element was originally\ncreated. The time stamp can serve as an indication as to whether the\nanalysis needs to be updated.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:dateTime"),("name","created")]}),("createdBy",Spdx3Property {_propertySummary = "Identifies who or what created the Element.", _propertyDescription = "CreatedBy identifies who or what created the Element. The generation\nmethod will assist the recipient of the Element in assessing the general\nreliability/accuracy of the analysis information.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Entity"),("name","createdBy")]}),("creationInfo",Spdx3Property {_propertySummary = "Provides information about the creation of the Element.", _propertyDescription = "CreationInfo provides information about the creation of the Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","CreationInformation"),("name","creationInfo")]}),("dataLicense",Spdx3Property {_propertySummary = "Provides the license under which the SPDX documentation of the Element\ncan be used.", _propertyDescription = "The data license provides the license under which the SPDX documentation\nof the Element can be used. This is to alleviate any concern that\ncontent (the data or database) in an SPDX file is subject to any form of\nintellectual property right that could restrict the re-use of the\ninformation or the creation of another SPDX file for the same\nproject(s). This approach avoids intellectual property and related\nrestrictions over the SPDX file, however individuals can still contract\nwith each other to restrict release of specific collections of SPDX\nfiles (which map to software bill of materials) and the identification\nof the supplier of SPDX files. Compliance with this document includes\npopulating the SPDX fields therein with data related to such fields\n(\"SPDX-Metadata\"). This document contains numerous fields where an SPDX\nfile creator may provide relevant explanatory text in SPDX-Metadata.\nWithout opining on the lawfulness of \"database rights\" (in jurisdictions\nwhere applicable), such explanatory text is copyrightable subject matter\nin most Berne Convention countries. By using the SPDX specification, or\nany portion hereof, you hereby agree that any copyright rights (as\ndetermined by your jurisdiction) in any SPDX-Metadata, including without\nlimitation explanatory text, shall be subject to the terms of the\nCreative Commons CC0 1.0 Universal license. For SPDX-Metadata not\ncontaining any copyright rights, you hereby agree and acknowledge that\nthe SPDX-Metadata is provided to you \8220as-is\8221 and without any\nrepresentations or warranties of any kind concerning the SPDX-Metadata,\nexpress, implied, statutory or otherwise, including without limitation\nwarranties of title, merchantability, fitness for a particular purpose,\nnon-infringement, or the absence of latent or other defects, accuracy,\nor the presence or absence of errors, whether or not discoverable, all\nto the greatest extent permissible under applicable law.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","dataLicense")]}),("description",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A description is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","description")]}),("element",Spdx3Property {_propertySummary = "Refers to one or more Elements that are part of an ElementCollection.", _propertyDescription = "This field refers to one or more Elements that are part of an\nElementCollection.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","element")]}),("extensions",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "TODO", _propertyMetadata = fromList [("name","extensions")]}),("externalId",Spdx3Property {_propertySummary = "Identifies an external Element used within a Document but defined\nexternal to that Document.", _propertyDescription = "ExternalId identifies an external Element used within a Document but\ndefined external to that Document.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","externalId")]}),("externalIdentifierType",Spdx3Property {_propertySummary = "Specifies the type of the external identifier.", _propertyDescription = "An externalIdentifierType specifies the type of the external identifier.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ExternalIdentifierType"),("name","externalIdentifierType")]}),("externalIdentifiers",Spdx3Property {_propertySummary = "Provides a reference to a resource outside the scope of SPDX-3.0 content\nthat uniquely identifies an Element.", _propertyDescription = "ExternalIdentifier points to a resource outside the scope of SPDX-3.0\ncontent that uniquely identifies an Element.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","ExternalIdentifier"),("name","externalIdentifiers")]}),("externalReferenceType",Spdx3Property {_propertySummary = "Specifies the type of the external reference.", _propertyDescription = "An externalReferenceType specifies the type of the external reference.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ExternalReferenceType"),("name","externalReferenceType")]}),("externalReferences",Spdx3Property {_propertySummary = "Points to a resource outside the scope of the SPDX-3.0 content that\nprovides additional characteristics of an Element.", _propertyDescription = "This field points to a resource outside the scope of the SPDX-3.0\ncontent that provides additional characteristics of an Element.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","ExternalReference"),("name","externalReferences")]}),("from",Spdx3Property {_propertySummary = "References the Element on the left-hand side of a relationship.", _propertyDescription = "This field references the Element on the left-hand side of a\nrelationship.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","from")]}),("hashValue",Spdx3Property {_propertySummary = "The result of applying a hash algorithm to an Element.", _propertyDescription = "HashValue is the result of applying a hash algorithm to an Element.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","hashValue")]}),("imports",Spdx3Property {_propertySummary = "Provides an ExternalMap of Element identifiers.", _propertyDescription = "Imports provides an ExternalMap of Element identifiers that are used\nwithin a document but defined external to that document.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ExternalMap"),("name","imports")]}),("locationHint",Spdx3Property {_propertySummary = "Provides an indication of where to retrieve an external Element.", _propertyDescription = "A locationHint provides an indication of where to retrieve an external\nElement.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","locationHint")]}),("locator",Spdx3Property {_propertySummary = "Provides the location of an external reference.", _propertyDescription = "A locator provides the location of an external reference.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","locator")]}),("name",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A name is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","name")]}),("namespace",Spdx3Property {_propertySummary = "Provides an unambiguous mechanism for other documents to reference\nElements within this document.", _propertyDescription = "A namespace provides an unambiguous mechanism for other documents to\nreference Elements within this document.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","namespace")]}),("namespaces",Spdx3Property {_propertySummary = "Provides a NamespaceMap applicable to an ElementCollection.", _propertyDescription = "This field provides a NamespaceMap applicable to an ElementCollection.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","NamespaceMap"),("name","namespaces")]}),("originatedBy",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A originatedBy is TODO", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Identity"),("name","originatedBy")]}),("prefix",Spdx3Property {_propertySummary = "A substitute for a URI.", _propertyDescription = "A prefix is a substitute for a URI.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","prefix")]}),("profile",Spdx3Property {_propertySummary = "Provides information about which profiles the Element belongs to.", _propertyDescription = "This field provides information about which profiles the Element belongs\nto.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","ProfileIdentifier"),("name","profile")]}),("relationshipType",Spdx3Property {_propertySummary = "Information about the relationship between two Elements.", _propertyDescription = "This field provides information about the relationship between two\nElements. For example, you can represent a relationship between two\ndifferent Files, between a Package and a File, between two Packages, or\nbetween one SPDXDocument and another SPDXDocument.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","RelationshipType"),("name","relationshipType")]}),("rootElement",Spdx3Property {_propertySummary = "Top level Element from which all other Elements are reached via\nrelationships.", _propertyDescription = "A rootElement of a collection is the top level Element from which all\nother Elements are reached via relationships.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","rootElement")]}),("spdxId",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A spdxId is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","spdxId")]}),("specVersion",Spdx3Property {_propertySummary = "Provides a reference number that can be used to understand how to parse\nand interpret an Element.", _propertyDescription = "The specVersion provides a reference number that can be used to\nunderstand how to parse and interpret an Element. It will enable both\nfuture changes to the specification and to support backward\ncompatibility. The major version number shall be incremented when\nincompatible changes between versions are made (one or more sections are\ncreated, modified or deleted). The minor version number shall be\nincremented when backwards compatible changes are made.\n\nHere, parties exchanging information in accordance with the SPDX\nspecification need to provide 100% transparency as to which SPDX\nspecification version such information is conforming to.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SemVer"),("name","specVersion")]}),("statement",Spdx3Property {_propertySummary = "Commentary on an assertion that an annotator has made.", _propertyDescription = "A statement is a commentary on an assertion that an annotator has made.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","statement")]}),("subject",Spdx3Property {_propertySummary = "An Element an annotator has made an assertion about.", _propertyDescription = "A subject is an Element an annotator has made an assertion about.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","subject")]}),("summary",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A summary is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","summary")]}),("to",Spdx3Property {_propertySummary = "References an Element on the right-hand side of a relationship.", _propertyDescription = "This field references an Element on the right-hand side of a\nrelationship.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","Element"),("name","to")]}),("verifiedUsing",Spdx3Property {_propertySummary = "Provides an IntegrityMethod with which the integrity of an Element can\nbe asserted.", _propertyDescription = "VerifiedUsing provides an IntegrityMethod with which the integrity of an\nElement can be asserted.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","IntegrityMethod"),("name","verifiedUsing")]})], _profileVocabularies = fromList [("AnnotationType",Spdx3Vocabulary {_vocabularySummary = "Specifies the type of an annotation.", _vocabularyDescription = "AnnotationType specifies the type of an annotation.", _vocabularyMetadata = fromList [("name","AnnotationType")], _vocabularyEntries = fromList [("other","Used to store extra information about an Element which is not part of a\nReview (e.g. extra information provided during the creation of the\nElement)."),("review","Used when someone reviews the Element.")]}),("ExternalIdentifierType",Spdx3Vocabulary {_vocabularySummary = "Specifies the type of an external identifier.", _vocabularyDescription = "ExteralIdentifierType specifies the type of an external identifier.", _vocabularyMetadata = fromList [("name","ExternalIdentifierType")], _vocabularyEntries = fromList [("cpe22","https://cpe.mitre.org/files/cpe-specification\\_2.2.pdf"),("cpe23","https://nvlpubs.nist.gov/nistpubs/Legacy/IR/nistir7695.pdf"),("email","TODOdescription"),("gitoid","gitoid stands for Git Object ID. A gitoid of typeblob is a unique hash\nof a software artifact. Git relies on a Merkle Tree to index stored\nobjects. See https://git-scm.com/book/en/v2/Git-Internals-Git-Objects.\nGitBOM is an amalgam of the terms \"Git\" and \"SBOM\". GitBOM is a\nminimalistic schema to describe software dependency graphs using a\nMerkle Tree, and is inspired by Git. A gitoid may refer to either the\nsoftware artifact or its GitBOM document; this ambiguity exists because\nthe GitBOM document is itself an artifact, and the gitoid of that\nartifact is its valid locator."),("other","Used when the type doesn't match any of the other options."),("pkgUrl","https://github.com/package-url/purl-spec"),("swhid","https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html"),("swid","https://www.ietf.org/archive/id/draft-ietf-sacm-coswid-21.html#section-2.3"),("urlScheme","TODOdescription")]}),("ExternalReferenceType",Spdx3Vocabulary {_vocabularySummary = "Specifies the type of an external reference.", _vocabularyDescription = "ExteralReferenceType specifies the type of an external reference.", _vocabularyMetadata = fromList [("name","ExternalReferenceType")], _vocabularyEntries = fromList [("altDownloadLocation","A reference to an alternative download location."),("altWebPage","A reference to an alternative web page."),("other","Used when the type doesn't match any of the other options."),("securityAdvisory","A reference to the published security advisory (where advisory as\ndefined per ISO 29147:2018). It may contain an impact statement whether\na package (e.g. a product) is or is not affected by vulnerabilities."),("securityFix","A reference to the source code with a fix for the vulnerability (e.g., a\nGitHub commit)."),("securityOther","Used when the reference is security related but doesn't match any of the\nother types.")]}),("HashAlgorithm",Spdx3Vocabulary {_vocabularySummary = "A mathematical algorithm that maps data of arbitrary size to a bit\nstring.", _vocabularyDescription = "A HashAlgorithm is a mathematical algorithm that maps data of arbitrary\nsize to a bit string (the hash) and is a one-way function, that is, a\nfunction which is practically infeasible to invert.", _vocabularyMetadata = fromList [("name","HashAlgorithm")], _vocabularyEntries = fromList [("blake2b256","TODOdescription"),("blake2b384","TODOdescription"),("blake2b512","TODOdescription"),("blake3","TODOdescription"),("md2","TODOdescription"),("md4","TODOdescription"),("md5","TODOdescription"),("md6","TODOdescription"),("other","TODOdescription"),("sha1","TODOdescription"),("sha224","TODOdescription"),("sha256","TODOdescription"),("sha384","TODOdescription"),("sha3_224","TODOdescription"),("sha3_256","TODOdescription"),("sha3_384","TODOdescription"),("sha3_512","TODOdescription"),("sha512","TODOdescription"),("spdxPvcSha1","TODOdescription"),("spdxPvcSha256","TODOdescription")]}),("RelationshipCompleteness",Spdx3Vocabulary {_vocabularySummary = "Indicates whether a relationship is complete or known to be incomplete\nor if there is made no assertion either way.", _vocabularyDescription = "RelationshipCompleteness indicates whether a relationship is complete or\nknown to be incomplete or if there is made no assertion either way.", _vocabularyMetadata = fromList [("name","RelationshipCompleteness")], _vocabularyEntries = fromList [("complete","The relationship is known to be exhaustive."),("incomplete","The relationship is known not to be exhaustive."),("unknown","There can be made no assertion about the completeness of the\nrelationship.")]}),("RelationshipType",Spdx3Vocabulary {_vocabularySummary = "Information about the relationship between two Elements.", _vocabularyDescription = "Provides information about the relationship between two Elements. For\nexample, you can represent a relationship between two different Files,\nbetween a Package and a File, between two Packages, or between one\nSPDXDocument and another SPDXDocument.\n\nBuild Profile specific RelationshipType descriptions can be found\n[here](https://github.com/spdx/spdx-3-build-profile/blob/main/model/relationships.md)", _vocabularyMetadata = fromList [("name","RelationshipType")], _vocabularyEntries = fromList [("amends","TODOdescription"),("ancestor","TODOdescription"),("buildChildOf","Build instance that was created from another build instance"),("buildConfigOf","Build configuration of the build instance"),("buildDependency","TODOdescription"),("buildHostOf","Element in which the build instance runs on"),("buildInputOf","Input to the build instance"),("buildInvokedBy","Agent that invoked the build"),("buildOnBehalfOf","Person for which buildInvokedBy is acting on behalf of"),("buildOutputOf","Output of the build instance"),("buildTool","TODOdescription"),("buildToolOf","Build tool used in the build instance"),("contains","TODOdescription"),("copy","TODOdescription"),("dataFile","TODOdescription"),("dependencyManifest","TODOdescription"),("dependsOn","TODOdescription"),("descendant","TODOdescription"),("describes","TODOdescription"),("devDependency","TODOdescription"),("devTool","TODOdescription"),("distributionArtifact","TODOdescription"),("documentation","TODOdescription"),("dynamicLink","TODOdescription"),("example","TODOdescription"),("expandedFromArchive","TODOdescription"),("fileAdded","TODOdescription"),("fileDeleted","TODOdescription"),("fileModified","TODOdescription"),("generates","TODOdescription"),("metafile","TODOdescription"),("optionalComponent","TODOdescription"),("optionalDependency","TODOdescription"),("other","TODOdescription"),("packages","TODOdescription"),("patch","TODOdescription"),("prerequisite","TODOdescription"),("providedDependency","TODOdescription"),("requirementFor","TODOdescription"),("runtimeDependency","TODOdescription"),("specificationFor","TODOdescription"),("staticLink","TODOdescription"),("suppliedBy","TODOdescription"),("test","TODOdescription"),("testCase","TODOdescription"),("testDependency","TODOdescription"),("testTool","TODOdescription"),("variant","TODOdescription")]})], _profileClasses = fromList [("Annotation",Spdx3Class {_classSummary = "An assertion made in relation to one or more elements.", _classDescription = "An Annotation is an assertion made in relation to one or more elements.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Element"),("name","Annotation")], _classProperties = fromList [("annotationType",Spdx3ClassPropertyParameters {_propertyType = "AnnotationType", _minCount = Just 1, _maxCount = Just 1}),("contentType",Spdx3ClassPropertyParameters {_propertyType = "MediaType", _minCount = Nothing, _maxCount = Nothing}),("statement",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("subject",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Just 1})]}),("AnonymousPayload",Spdx3Class {_classSummary = "TODO", _classDescription = "TODO", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Payload"),("name","AnonymousPayload")], _classProperties = fromList [("creationInfo",Spdx3ClassPropertyParameters {_propertyType = "CreationInformation", _minCount = Just 0, _maxCount = Just 1}),("imports",Spdx3ClassPropertyParameters {_propertyType = "ExternalMap", _minCount = Nothing, _maxCount = Nothing}),("namespaces",Spdx3ClassPropertyParameters {_propertyType = "NamespaceMap", _minCount = Nothing, _maxCount = Nothing})]}),("Artifact",Spdx3Class {_classSummary = "A distinct article or unit within the digital domain.", _classDescription = "An artifact is a distinct article or unit within the digital domain,\nsuch as an electronic file, a software package, a device or an element\nof data.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","Element"),("name","Artifact")], _classProperties = fromList [("originatedBy",Spdx3ClassPropertyParameters {_propertyType = "Identity", _minCount = Just 0, _maxCount = Nothing})]}),("Bom",Spdx3Class {_classSummary = "A container for a grouping of SPDX-3.0 content characterizing details\n(provenence, composition, licensing, etc.) about a product.", _classDescription = "A Bill Of Materials (BOM) is a container for a grouping of SPDX-3.0\ncontent characterizing details about a product. This could include\ndetails of the content and composition of the product, provenence\ndetails of the product and/or its composition, licensing information,\nknown quality or security issues, etc.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Bundle"),("name","Bom")], _classProperties = fromList []}),("Bundle",Spdx3Class {_classSummary = "A collection of Elements that have a shared context.", _classDescription = "A bundle is a collection of Elements that have a shared context.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","ElementCollection"),("name","Bundle")], _classProperties = fromList [("context",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1})]}),("CreationInformation",Spdx3Class {_classSummary = "Provides information about the creation of the Element.", _classDescription = "The CreationInformation provides information about who created the\nElement, and when and how it was created.", _classMetadata = fromList [("Instantiability","Concrete"),("name","CreationInformation")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("created",Spdx3ClassPropertyParameters {_propertyType = "xsd:dateTime", _minCount = Nothing, _maxCount = Nothing}),("createdBy",Spdx3ClassPropertyParameters {_propertyType = "Entity", _minCount = Just 1, _maxCount = Nothing}),("dataLicense",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Nothing}),("profile",Spdx3ClassPropertyParameters {_propertyType = "ProfileIdentifier", _minCount = Just 1, _maxCount = Nothing}),("specVersion",Spdx3ClassPropertyParameters {_propertyType = "SemVer", _minCount = Nothing, _maxCount = Nothing})]}),("Element",Spdx3Class {_classSummary = "Base domain class from which all other SPDX-3.0 domain classes derive.", _classDescription = "An Element is a representation of a fundamental concept either directly\ninherent to the Bill of Materials (BOM) domain or indirectly related to\nthe BOM domain and necessary for contextually characterizing BOM\nconcepts and relationships. Within SPDX-3.0 structure this is the base\nclass acting as a consistent, unifying, and interoperable foundation for\nall explicit and inter-relatable content objects.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","Payload"),("name","Element")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("creationInfo",Spdx3ClassPropertyParameters {_propertyType = "CreationInformation", _minCount = Just 1, _maxCount = Just 1}),("description",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("extensions",Spdx3ClassPropertyParameters {_propertyType = "Extension", _minCount = Nothing, _maxCount = Nothing}),("externalIdentifiers",Spdx3ClassPropertyParameters {_propertyType = "ExternalIdentifier", _minCount = Nothing, _maxCount = Nothing}),("externalReferences",Spdx3ClassPropertyParameters {_propertyType = "ExternalReference", _minCount = Nothing, _maxCount = Nothing}),("name",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("spdxId",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 1, _maxCount = Just 1}),("summary",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("verifiedUsing",Spdx3ClassPropertyParameters {_propertyType = "IntegrityMethod", _minCount = Nothing, _maxCount = Nothing})]}),("ElementCollection",Spdx3Class {_classSummary = "A collection of Elements, not necessarily with unifying context.", _classDescription = "An SpdxCollection is a collection of Elements, not necessarily with\nunifying context.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","Element"),("name","ElementCollection")], _classProperties = fromList [("element",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Nothing}),("imports",Spdx3ClassPropertyParameters {_propertyType = "ExternalMap", _minCount = Nothing, _maxCount = Nothing}),("namespaces",Spdx3ClassPropertyParameters {_propertyType = "NamespaceMap", _minCount = Nothing, _maxCount = Nothing}),("rootElement",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Nothing})]}),("Entity",Spdx3Class {_classSummary = "TODO", _classDescription = "TODO", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Element"),("name","Entity")], _classProperties = fromList []}),("ExternalIdentifier",Spdx3Class {_classSummary = "A reference to a resource outside the scope of SPDX-3.0 content that\nuniquely identifies an Element.", _classDescription = "An ExternalIdentifier is a reference to a resource outside the scope of\nSPDX-3.0 content that uniquely identifies an Element.", _classMetadata = fromList [("Instantiability","Concrete"),("name","ExternalIdentifier")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("externalIdentifierType",Spdx3ClassPropertyParameters {_propertyType = "ExternalIdentifierType", _minCount = Just 1, _maxCount = Just 1}),("identifier",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1})]}),("ExternalMap",Spdx3Class {_classSummary = "A map of Element identifiers that are used within a Document but defined\nexternal to that Document.", _classDescription = "An External Map is a map of Element identifiers that are used within a\nDocument but defined external to that Document. The external map\nprovides details about the externally-defined Element such as its\nprovenance, where to retrieve it, and how to verify its integrity.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","none"),("name","ExternalMap")], _classProperties = fromList [("externalId",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 1, _maxCount = Just 1}),("locationHint",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Nothing, _maxCount = Just 1}),("verifiedUsing",Spdx3ClassPropertyParameters {_propertyType = "IntegrityMethod", _minCount = Nothing, _maxCount = Nothing})]}),("ExternalReference",Spdx3Class {_classSummary = "A reference to a resource outside the scope of SPDX-3.0 content.", _classDescription = "An External Reference points to a resource outside the scope of the\nSPDX-3.0 content that provides additional characteristics of an Element.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","none"),("name","ExternalReference")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1}),("contentType",Spdx3ClassPropertyParameters {_propertyType = "MediaType", _minCount = Nothing, _maxCount = Just 1}),("externalReferenceType",Spdx3ClassPropertyParameters {_propertyType = "ExternalReferenceType", _minCount = Nothing, _maxCount = Just 1}),("locator",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Nothing, _maxCount = Nothing})]}),("Hash",Spdx3Class {_classSummary = "A mathematically calculated representation of a grouping of data.", _classDescription = "A hash is a grouping of characteristics unique to the result of applying\na mathematical algorithm that maps data of arbitrary size to a bit\nstring (the hash) and is a one-way function, that is, a function which\nis practically infeasible to invert. This is commonly used for integrity\nchecking of data.", _classMetadata = fromList [("SubclassOf","IntegrityMethod"),("name","Hash")], _classProperties = fromList [("algorithm",Spdx3ClassPropertyParameters {_propertyType = "HashAlgorithm", _minCount = Just 1, _maxCount = Just 1}),("hashValue",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1})]}),("Identity",Spdx3Class {_classSummary = "An individual or organization.", _classDescription = "An Identity is a grouping of identifying characteristics unique to an\nindividual or organization.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Entity"),("name","Identity")], _classProperties = fromList []}),("IntegrityMethod",Spdx3Class {_classSummary = "Provides an independently reproducible mechanism that permits\nidentification of a specific Element.", _classDescription = "An IntegrityMethod provides an independently reproducible mechanism that\npermits identification of a specific Element that correlates to the data\nin this SPDX document. This identifier enables a recipient to determine\nif anything in the original Element has been changed and eliminates\nconfusion over which version or modification of a specific Element is\nreferenced.", _classMetadata = fromList [("Instantiability","Abstract"),("name","IntegrityMethod")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1})]}),("MediaType",Spdx3Class {_classSummary = "Standardized way of indicating the type of content of an Element. A\nString constrained to the RFC 2046 specification.", _classDescription = "The MediaType is a String constrained to the RFC 2046 specification. It\nprovides a standardized way of indicating the type of content of an\nElement. A list of all possible media types is available at\nhttps://www.iana.org/assignments/media-types/media-types.xhtml.", _classMetadata = fromList [("SubclassOf","xsd:string"),("name","MediaType")], _classProperties = fromList []}),("NamespaceMap",Spdx3Class {_classSummary = "A mapping between prefixes and namespace URIs.", _classDescription = "A namespace map allows the creator of a collection of Elements to use\nshorter identifiers (\"prefixes\") instead of URIs to provide a more\nhuman-readable and smaller serialized representation of the Elements.", _classMetadata = fromList [("Instantiability","Concrete"),("name","NamespaceMap")], _classProperties = fromList [("namespace",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Nothing, _maxCount = Just 1}),("prefix",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Nothing, _maxCount = Just 1})]}),("Organization",Spdx3Class {_classSummary = "A group of people who work together in an organized way for a shared\npurpose.", _classDescription = "An Organization is a group of people who work together in an organized\nway for a shared purpose.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Identity"),("name","Organization")], _classProperties = fromList []}),("Payload",Spdx3Class {_classSummary = "TODO", _classDescription = "TODO", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","none"),("name","Payload")], _classProperties = fromList [("creationInfo",Spdx3ClassPropertyParameters {_propertyType = "CreationInformation", _minCount = Just 0, _maxCount = Just 1}),("imports",Spdx3ClassPropertyParameters {_propertyType = "ExternalMap", _minCount = Nothing, _maxCount = Nothing}),("namespaces",Spdx3ClassPropertyParameters {_propertyType = "NamespaceMap", _minCount = Nothing, _maxCount = Nothing})]}),("Person",Spdx3Class {_classSummary = "An individual human being.", _classDescription = "A Person is an individual human being.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Identity"),("name","Person")], _classProperties = fromList []}),("ProfileIdentifier",Spdx3Class {_classSummary = "Provides the profile that the Element is specified in.", _classDescription = "A profile identifier provides the profile that the Element is specified\nin.", _classMetadata = fromList [("SubclassOf","xsd:string"),("name","ProfileIdentifier")], _classProperties = fromList []}),("Relationship",Spdx3Class {_classSummary = "Describes a relationship between one or more elements.", _classDescription = "A Relationship is a grouping of characteristics unique to an assertion\nthat one Element is related to one or more other Elements in some way.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Element"),("name","Relationship")], _classProperties = fromList [("completeness",Spdx3ClassPropertyParameters {_propertyType = "RelationshipCompleteness", _minCount = Just 0, _maxCount = Just 1}),("from",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Just 1}),("relationshipType",Spdx3ClassPropertyParameters {_propertyType = "RelationshipType", _minCount = Nothing, _maxCount = Just 1}),("to",Spdx3ClassPropertyParameters {_propertyType = "Element", _minCount = Just 1, _maxCount = Nothing})]}),("SemVer",Spdx3Class {_classSummary = "A String constrained to the SemVer 2.0.0 specification.", _classDescription = "The semantic version is a String constrained to the SemVer 2.0.0\nspecification.", _classMetadata = fromList [("SubclassOf","xsd:string"),("name","SemVer")], _classProperties = fromList []}),("SpdxDocument",Spdx3Class {_classSummary = "Assembles a collection of Elements under a common string, the name of\nthe document.", _classDescription = "An SpdxDocument assembles a collection of Elements under a common\nstring, the name of the document. Commonly used when representing a unit\nof transfer of SPDX Elements.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Bundle"),("name","SpdxDocument")], _classProperties = fromList [("name",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1})]}),("Tool",Spdx3Class {_classSummary = "An element of hardware and/or software utilized to carry out a\nparticular function.", _classDescription = "A Tool is an element of hardware and/or software utilized to carry out a\nparticular function.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Entity"),("name","Tool")], _classProperties = fromList []})]}),("Licensing",Spdx3Profile {_profileSummary = "TODO", _profileDescription = "TODO", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3#Licensing"),("name","Licensing")], _profileProperties = fromList [("attributionText",Spdx3Property {_propertySummary = "An attributionText provides a place for the SPDX data creator to record\nacknowledgement text for a software Package, File or Snippet.", _propertyDescription = "An attributionText for a software Package, File or Snippet provides a\nconsumer of SPDX data with acknowledgement content, to assist\nredistributors of the Package, File or Snippet with reproducing those\nacknowledgements.\n\nFor example, this field may include a statement that is required by a\nparticular license to be reproduced in end-user documentation,\nadvertising materials, or another form.\n\nThis field may describe where, or in which contexts, the\nacknowledgements need to be reproduced, but it is not required to do so.\nThe SPDX data creator may also explain elsewhere (such as in a\nlicenseComment field) how they intend for data in this field to be used.\n\nAn attributionText is is not meant to include the software Package, File\nor Snippet\8217s actual complete license text (see concludedLicense to\nidentify the corresponding license).", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","attributionText")]}),("concludedLicense",Spdx3Property {_propertySummary = "A concludedLicense identifies the license that that SPDX data creator\nhas concluded as governing the software Package, File or Snippet.", _propertyDescription = "A concludedLicense is the license identified by the SPDX data creator,\nbased on analyzing the license information in the software Package, File\nor Snippet and other information to arrive at a reasonably objective\nconclusion as to what license governs it.\n\nIf a concludedLicense has a NONE value (NoneLicense), this indicates\nthat the SPDX data creator has looked and did not find any license\ninformation for this software Package, File or Snippet.\n\nIf a concludedLicense has a NOASSERTION value (NoAssertionLicense), this\nindicates that one of the following applies: \\* the SPDX data creator\nhas attempted to but cannot reach a reasonable objective determination;\n\\* the SPDX data creator has made no attempt to determine this field; or\n\\* the SPDX data creator has intentionally provided no information (no\nmeaning should be implied by doing so).\n\nA written explanation of a NOASSERTION value (NoAssertionLicense) MAY be\nprovided in the licenseComment field.\n\nIf the concludedLicense for a software Package, File or Snippet is not\nthe same as its declaredLicense, a written explanation SHOULD be\nprovided in the licenseComment field.\n\nIf the declaredLicense for a software Package, File or Snippet is a\nchoice of more than one license (e.g. a license expression combining two\nlicenses through use of the `OR` operator), then the concludedLicense\nmay either retain the license choice or identify which license was\nchosen.", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","LicenseField"),("name","concludedLicense")]}),("copyrightText",Spdx3Property {_propertySummary = "A copyrightText identifies the text of one or more copyright notices for\na software Package, File or Snippet, if any.", _propertyDescription = "A copyrightText consists of the text(s) of the copyright notice(s) found\nfor a software Package, File or Snippet, if any.\n\nIf a copyrightText contains text, then it may contain any text related\nto one or more copyright notices (even if not complete) for that\nsoftware Package, File or Snippet.\n\nIf a copyrightText has a NONE value, this indicates that the software\nPackage, File or Snippet contains no copyright notice whatsoever.\n\nIf a copyrightText has a NOASSERTION value, this indicates that one of\nthe following applies: \\* the SPDX data creator has attempted to but\ncannot reach a reasonable objective determination; \\* the SPDX data\ncreator has made no attempt to determine this field; or \\* the SPDX data\ncreator has intentionally provided no information (no meaning should be\nimplied by doing so).", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","CopyrightTextField"),("name","copyrightText")]}),("declaredLicense",Spdx3Property {_propertySummary = "A declaredLicense identifies the license information actually found in\nthe software Package, File or Snippet, for example as detected by use of\nautomated tooling.", _propertyDescription = "A declaredLicense is the license identified in text in the software\npackage, file or snippet as the license declared by its authors.\n\nThis field is not intended to capture license information obtained from\nan external source, such as a package's website. Such information can be\nincluded, as needed, in a concludedLicense field.\n\nA declaredLicense may be expressed differently in practice for different\ntypes of artifacts. For example:\n\n-   for Packages:\n    -   would include license info describing the license of the Package\n        as a whole, when it is found in the Package itself (e.g.,\n        LICENSE file, README file, metadata in the repository, etc.)\n    -   would not include any license information that is not in the\n        Package itself (e.g., license information from the project\8217s\n        website or from a third party repository or website)\n-   for Files:\n    -   would include license info found in the File itself (e.g.,\n        license header or notice, comments, SPDX-License-Identifier\n        expression)\n    -   would not include license info found in a different file (e.g.,\n        LICENSE file in the top directory of a repository)\n-   for Snippets:\n    -   would include license info found in the Snippet itself (e.g.,\n        license notice, comments, SPDX-License-Identifier expression)\n    -   would not include license info found elsewhere in the File or in\n        a different File (e.g., comment at top of File if it is not\n        within the Snippet, LICENSE file in the top directory of a\n        repository)\n\nIf a declaredLicense has a NONE value (NoneLicense), this indicates that\nthe corresponding Package, File or Snippet contains no license\ninformation whatsoever.\n\nIf a declaredLicense has a NOASSERTION value (NoAssertionLicense), this\nindicates that one of the following applies: \\* the SPDX data creator\nhas attempted to but cannot reach a reasonable objective determination;\n\\* the SPDX data creator has made no attempt to determine this field; or\n\\* the SPDX data creator has intentionally provided no information (no\nmeaning should be implied by doing so).", _propertyMetadata = fromList [("Nature","ObjectProperty"),("Range","LicenseField"),("name","declaredLicense")]}),("licenseComment",Spdx3Property {_propertySummary = "A licenseComment records any background information or analysis relevant\nto determining the concludedLicense for a software Package, File or\nSnippet.", _propertyDescription = "A licenseComment for a software Package, File or Snippet provides a\ndetailed explanation of how the concludedLicense was determined,\nespecially if: \\* the concludedLicense does not match the\ndeclaredLicense; \\* the concludedLicense is NOASSERTION; or \\* the SPDX\ndata creator wants to provide other helpful information relevant to\ndetermining the license of the software Package, File or Snippet.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","licenseComment")]})], _profileVocabularies = fromList [], _profileClasses = fromList [("ConjunctiveLicenseSet",Spdx3Class {_classSummary = "Portion of a LicenseExpression representing a set of licensing\ninformation where all elements apply.", _classDescription = "A ConjunctiveLicenseSet indicates that *each* of its subsidiary\nLicenseExpressions apply. In other words, a ConjunctiveLicenseSet of two\nor more licenses represents a licensing situation where *all* of the\nspecified licenses are to be complied with. It is represented in the\nSPDX License Expression Syntax by the `AND` operator.\n\nIt is syntactically correct to specify a ConjunctiveLicenseSet where the\nsubsidiary LicenseExpressions may be \"incompatible\" according to a\nparticular interpretation of the corresponding Licenses. The SPDX\nLicense Expression Syntax does not take into account interpretation of\nlicense texts, which is left to the consumer of SPDX data to determine\nfor themselves.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseExpression"),("name","ConjunctiveLicenseSet")], _classProperties = fromList [("child",Spdx3ClassPropertyParameters {_propertyType = "LicenseExpression", _minCount = Just 2, _maxCount = Nothing})]}),("CopyrightText",Spdx3Class {_classSummary = "Concrete class representing copyright text that has actually been found.", _classDescription = "A CopyrightText is the primary value that is used by a copyrightText\nfield that indicates copyright text being found, i.e. with a value other\nthan NONE or NOASSERTION.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","CopyrightTextField"),("name","CopyrightText")], _classProperties = fromList [("text",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1})]}),("CopyrightTextField",Spdx3Class {_classSummary = "Base abstract class used for the copyrightText field that can take a\nvalue of either a text value (via CopyrightText), NOASSERTION, or NONE.", _classDescription = "A CopyrightTextField is the primary value that is used by a copyright\ntext field for a software Package, File or Snippet. It represents either\nactual text (represented via a concrete CopyrightText), or the values\nNOASSERTION or NONE.\n\n**FIXME** The specific meanings of NOASSERTION or NONE are defined in\nthe copyrightText property description. (**INCORRECT** - change to\nNoAssertionText or NoneText)", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","none"),("name","CopyrightTextField")], _classProperties = fromList []}),("CustomLicense",Spdx3Class {_classSummary = "A license that is not listed on the SPDX License List.", _classDescription = "A CustomLicense represents a License that is not listed on the SPDX\nLicense List at https://spdx.org/licenses, and is therefore defined by\nan SPDX data creator.\n\n**TBD** whether to define the meaning and purpose for each of the\nproperties\n\n**TBD** how to indicate that the License ID must have the prefix\n\"LicenseRef-\"", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","License"),("name","CustomLicense")], _classProperties = fromList []}),("CustomLicenseException",Spdx3Class {_classSummary = "**TBD** Not to be completed until the Change Proposal at\nhttps://github.com/spdx/change-proposal/issues/4 is decided upon. Should\nbe treated as unconfirmed since this class and its name or meaning is\nsubject to change.", _classDescription = "MISSING", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseException"),("name","CustomLicenseException")], _classProperties = fromList []}),("DisjunctiveLicenseSet",Spdx3Class {_classSummary = "Portion of a LicenseExpression representing a set of licensing\ninformation where only any one of the elements applies.", _classDescription = "A DisjunctiveLicenseSet indicates that *only one* of its subsidiary\nLicenseExpressions is required to apply. In other words, a\nDisjunctiveLicenseSet of two or more licenses represents a licensing\nsituation where *only one* of the specified licenses are to be complied\nwith. A consumer of SPDX data would typically understand this to permit\nthe recipient of the licensed content to choose which of the\ncorresponding license they would prefer to use. It is represented in the\nSPDX License Expression Syntax by the `OR` operator.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseExpression"),("name","DisjunctiveLicenseSet")], _classProperties = fromList [("child",Spdx3ClassPropertyParameters {_propertyType = "LicenseExpression", _minCount = Just 2, _maxCount = Nothing})]}),("License",Spdx3Class {_classSummary = "Abstract class for the portion of a LicenseExpression representing a\nlicense.", _classDescription = "A License represents a license text, whether listed on the SPDX License\nList (ListedLicense) or defined by an SPDX data creator (CustomLicense).\n\n**TBD** whether to define the meaning and purpose for each of the\nproperties\n\n**TBD** whether licenseID should be a separately defined property,\nrather than xsd:string", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","LicenseExpression"),("name","License")], _classProperties = fromList [("comment",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("example",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("isDeprecatedLicenseId",Spdx3ClassPropertyParameters {_propertyType = "xsd:boolean", _minCount = Just 0, _maxCount = Just 1}),("isFsfLibre",Spdx3ClassPropertyParameters {_propertyType = "xsd:boolean", _minCount = Just 0, _maxCount = Just 1}),("isOsiApproved",Spdx3ClassPropertyParameters {_propertyType = "xsd:boolean", _minCount = Just 0, _maxCount = Just 1}),("licenseId",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("licenseText",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("name",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 1, _maxCount = Just 1}),("obsoletedBy",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("seeAlso",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 0, _maxCount = Just 1}),("standardLicenseHeader",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("LicenseException",Spdx3Class {_classSummary = "**TBD** Not to be completed until the Change Proposal at\nhttps://github.com/spdx/change-proposal/issues/4 is decided upon. Should\nbe treated as unconfirmed since this class and its name or meaning is\nsubject to change.", _classDescription = "MISSING", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","none"),("name","LicenseException")], _classProperties = fromList []}),("LicenseExpression",Spdx3Class {_classSummary = "Abstract class representing a license expression consisting of one or\nmore licenses (optionally including exceptions), which may be combined\naccording to the SPDX license expression syntax.", _classDescription = "A LicenseExpression is used by a licensing field for a software package,\nfile or snippet when its value is not NOASSERTION or NONE. It can be a\nsingle license (either on the SPDX License List or a custom-defined\nlicense); a single license with an \"or later\" operator applied; the\nforegoing with an exception applied; or a set of licenses combined by\napplying \"AND\" and \"OR\" operators recursively.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","LicenseField"),("name","LicenseExpression")], _classProperties = fromList []}),("LicenseField",Spdx3Class {_classSummary = "Base abstract class used for all fields that can take a value of either\na license expression, NOASSERTION, or NONE.", _classDescription = "A LicenseField is the primary value that is used by a licensing field\nfor a software Package, File or Snippet. It represents either a license\nexpression, or the values NOASSERTION or NONE. The specific meanings of\nNOASSERTION or NONE for the particular licensing field are defined in\nthe corresponding property description.", _classMetadata = fromList [("Instantiability","Abstract"),("SubclassOf","none"),("name","LicenseField")], _classProperties = fromList []}),("ListedLicense",Spdx3Class {_classSummary = "A license that is listed on the SPDX License List.", _classDescription = "A ListedLicense represents a License that is listed on the SPDX License\nList at https://spdx.org/licenses.\n\n**TBD** whether to define the meaning and purpose for each of the\nproperties", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","License"),("name","ListedLicense")], _classProperties = fromList [("deprecatedVersion",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1}),("listVersionAdded",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("ListedLicenseException",Spdx3Class {_classSummary = "**TBD** Not to be completed until the Change Proposal at\nhttps://github.com/spdx/change-proposal/issues/4 is decided upon. Should\nbe treated as unconfirmed since this class and its name or meaning is\nsubject to change.", _classDescription = "MISSING", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseException"),("name","ListedLicenseException")], _classProperties = fromList []}),("NoAssertionLicense",Spdx3Class {_classSummary = "Concrete class representing an absence of an assertion about license\ninformation.", _classDescription = "**TBD** whether the meaning of NoAssertionLicense in the context of the\nconcludedLicense and declaredLicense properties should be here rather\nthan in those property definitions\n\nA NoAssertionLicense is the primary value that is used by a\nconcludedLicense or declaredLicense field that indicates that the SPDX\ndata creator is making no assertion about the license information for\nthe corresponding software Package, File or Snippet.\n\nThe specific meaning of NoAssertionLicense in the context of a\nconcludedLicense or declaredLicense field is more fully set forth in the\nProperty definitions for those fields.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseField"),("name","NoAssertionLicense")], _classProperties = fromList []}),("NoAssertionText",Spdx3Class {_classSummary = "Concrete class representing an absence of an assertion about the\npresence of copyright text.", _classDescription = "**TBD** whether these details should be defined in the copyrightText\nproperty instead of here\n\nA NoAssertionText is the primary value that is used by a copyrightText\nfield that indicates that the SPDX data creator is making no assertion\nabout whether any copyright information is present, or what its contents\nare if it is present.\n\nIf a copyrightText has a NOASSERTION value, this indicates that one of\nthe following applies: \\* the SPDX data creator has made no attempt to\ndetermine this field; or \\* the SPDX data creator has intentionally\nprovided no information (no meaning should be implied from the absence\nof an assertion).", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","CopyrightTextField"),("name","NoAssertionText")], _classProperties = fromList []}),("NoneLicense",Spdx3Class {_classSummary = "Concrete class representing an assertion that no license information is\npresent, as applicable.", _classDescription = "**TBD** whether the meaning of NoneLicense in the context of the\nconcludedLicense and declaredLicense properties should be here rather\nthan in those property definitions\n\nA NoneLicense is the primary value that is used by a concludedLicense or\ndeclaredLicense field that indicates the absence of license information\nfrom the corresponding software Package, File or Snippet.\n\nThe specific meaning of NoneLicense in the context of a concludedLicense\nor declaredLicense field is more fully set forth in the Property\ndefinitions for those fields.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseField"),("name","NoneLicense")], _classProperties = fromList []}),("NoneText",Spdx3Class {_classSummary = "Concrete class representing an assertion that no copyright text is\npresent.", _classDescription = "**TBD** whether these details should be defined in the copyrightText\nproperty instead of here\n\nA NoneText is the primary value that is used by a copyrightText field\nthat indicates that the corresponding software Package, File or Snippet\ndoes not contain any copyright information.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","CopyrightTextField"),("name","NoneText")], _classProperties = fromList []}),("OrLaterOperator",Spdx3Class {_classSummary = "Portion of a LicenseExpression representing this version, or any later\nversion, of the indicated License.", _classDescription = "An OrLaterOperator indicates that this portion of the LicenseExpression\nrepresents either (1) the specified version of the corresponding\nLicense, or (2) any later version of that License. It is represented in\nthe SPDX License Expression Syntax by the `+` operator.\n\nIt is context-dependent, and unspecified by SPDX, as to what constitutes\na \"later version\" of any particular License. Some Licenses may not be\nversioned, or may not have clearly-defined ordering for versions. The\nconsumer of SPDX data will need to determine for themselves what meaning\nto attribute to a \"later version\" operator for a particular License.", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseExpression"),("name","OrLaterOperator")], _classProperties = fromList [("license",Spdx3ClassPropertyParameters {_propertyType = "License", _minCount = Just 1, _maxCount = Just 1})]}),("WithExceptionOperator",Spdx3Class {_classSummary = "**TBD** Not to be completed until the Change Proposal at\nhttps://github.com/spdx/change-proposal/issues/4 is decided upon. Should\nbe treated as unconfirmed since this class and its name or meaning is\nsubject to change.", _classDescription = "MISSING", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","LicenseExpression"),("name","WithExceptionOperator")], _classProperties = fromList []})]}),("Software",Spdx3Profile {_profileSummary = "Everything having to do with software.", _profileDescription = "The Software namespace defines concepts related to software artifacts.", _profileMetadata = fromList [("id","https://rdf.spdx.org/v3#Software"),("name","Software")], _profileProperties = fromList [("byteRange",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A byteRange is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","positiveIntegerRange"),("name","byteRange")]}),("contentIdentifier",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A contentIdentifier is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","contentIdentifier")]}),("contentType",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A contentType is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","mediaType"),("name","contentType")]}),("downloadLocation",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A downloadLocation is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","downloadLocation")]}),("filePurpose",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A filePurpose is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SoftwarePurpose"),("name","filePurpose")]}),("homePage",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A homePage is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","homePage")]}),("lineRange",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A lineRange is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","positiveIntegerRange"),("name","lineRange")]}),("packagePurpose",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A packagePurpose is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SoftwarePurpose"),("name","packagePurpose")]}),("packageUrl",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A packageUrl is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","anyURI"),("name","packageUrl")]}),("packageVersion",Spdx3Property {_propertySummary = "Identify the version of a package.", _propertyDescription = "A packageVersion is useful for identification purposes and for\nindicating later changes of the package version.", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","xsd:string"),("name","packageVersion")]}),("snippetPurpose",Spdx3Property {_propertySummary = "TODO", _propertyDescription = "A snippetPurpose is TODO", _propertyMetadata = fromList [("Nature","DataProperty"),("Range","SoftwarePurpose"),("name","snippetPurpose")]})], _profileVocabularies = fromList [("DependencyLinkType",Spdx3Vocabulary {_vocabularySummary = "TODO", _vocabularyDescription = "TODO", _vocabularyMetadata = fromList [("name","DependencyLinkType")], _vocabularyEntries = fromList [("dynamic","TODOdescription"),("noAssertion","TODOdescription"),("other","TODOdescription"),("static","TODOdescription"),("tool","TODOdescription")]}),("DependencyRequirement",Spdx3Vocabulary {_vocabularySummary = "TODO", _vocabularyDescription = "TODO", _vocabularyMetadata = fromList [("name","DependencyRequirement")], _vocabularyEntries = fromList [("noAssertion","TODOdescription"),("optional","TODOdescription"),("preRequisite","TODOdescription"),("provided","TODOdescription"),("required","TODOdescription")]}),("DependencyScope",Spdx3Vocabulary {_vocabularySummary = "TODO", _vocabularyDescription = "TODO", _vocabularyMetadata = fromList [("name","DependencyScope")], _vocabularyEntries = fromList [("build","TODOdescription"),("dev","TODOdescription"),("noAssertion","TODOdescription"),("other","TODOdescription"),("runtime","TODOdescription"),("test","TODOdescription")]}),("SoftwarePurpose",Spdx3Vocabulary {_vocabularySummary = "TODO", _vocabularyDescription = "TODO", _vocabularyMetadata = fromList [("name","SoftwarePurpose")], _vocabularyEntries = fromList [("application","TODOdescription"),("archive","TODOdescription"),("bom","TODOdescription"),("configuration","TODOdescription"),("container","TODOdescription"),("data","TODOdescription"),("device","TODOdescription"),("documentation","TODOdescription"),("executable","TODOdescription"),("file","TODOdescription"),("firmware","TODOdescription"),("framework","TODOdescription"),("install","TODOdescription"),("library","TODOdescription"),("module","TODOdescription"),("operatingSystem","TODOdescription"),("other","TODOdescription"),("patch","TODOdescription"),("source","TODOdescription")]})], _profileClasses = fromList [("File",Spdx3Class {_classSummary = "MISSING", _classDescription = "TODO This is about the File class.", _classMetadata = fromList [("SubclassOf","Core:Artifact"),("name","File")], _classProperties = fromList [("contentIdentifier",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 0, _maxCount = Just 1}),("contentType",Spdx3ClassPropertyParameters {_propertyType = "MediaType", _minCount = Just 0, _maxCount = Just 1}),("filePurpose",Spdx3ClassPropertyParameters {_propertyType = "SoftwarePurpose", _minCount = Just 0, _maxCount = Nothing})]}),("Package",Spdx3Class {_classSummary = "MISSING", _classDescription = "If SPDX information is being used to describe packages, then one\ninstance of the package information per package being described shall\nexist. It provides important meta information about the package as a\nwhole. Packages are an abstract concept that can be used to refer to any\ndistribution of software, typically consisting of one or more files and\ncapable of containing sub-packages. Starting with SPDX 2.0, it is not\nnecessary to have a package wrapping a set of files.\n\nA package refers to any unit of content that can be associated with a\ndistribution of software. Typically, a package is composed of one or\nmore files. An SPDX document may, but is not required to, provide\ndetails about the individual files comprising a package (see File.md).\n\nAny of the following non-limiting examples may be (but are not required\nto be) represented in SPDX as a package:\n\n-   a tarball, zip file or other archive\n-   a directory or sub-directory\n-   a separately distributed piece of software which another Package or\n    File uses or depends upon (e.g., a Python package, a Go module, ...)\n-   a container image, and/or each image layer within a container image\n-   a collection of one or more sub-packages\n-   a Git repository snapshot from a particular point in time\n\nNote that some of these could be represented in SPDX as a file as well.\n\nIn an SPDX document, relationship elements can be used to indicate\nrelationships between packages, such as dependency relationships.\n\nCardinality: Optional, zero or many.", _classMetadata = fromList [("SubclassOf","Core:Artifact"),("name","Package")], _classProperties = fromList [("contentIdentifier",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 0, _maxCount = Just 1}),("downloadLocation",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 0, _maxCount = Just 1}),("homePage",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 0, _maxCount = Just 1}),("packagePurpose",Spdx3ClassPropertyParameters {_propertyType = "SoftwarePurpose", _minCount = Just 0, _maxCount = Nothing}),("packageUrl",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 0, _maxCount = Just 1}),("packageVersion",Spdx3ClassPropertyParameters {_propertyType = "xsd:string", _minCount = Just 0, _maxCount = Just 1})]}),("Sbom",Spdx3Class {_classSummary = "MISSING", _classDescription = "A Software Bill of Materials (SBOM) is a container for a grouping of\nSPDX-3.0 content characterizing details about a software product. This\ncould include details of the content and composition of the product,\nprovenence details of the product and/or its composition, licensing\ninformation, known quality or security issues, etc.", _classMetadata = fromList [("SubclassOf","Core:Bom"),("name","Sbom")], _classProperties = fromList []}),("Snippet",Spdx3Class {_classSummary = "MISSING", _classDescription = "TODO", _classMetadata = fromList [("SubclassOf","Core:Artifact"),("name","Snippet")], _classProperties = fromList [("byteRange",Spdx3ClassPropertyParameters {_propertyType = "positiveIntegerRange", _minCount = Just 0, _maxCount = Just 1}),("contentIdentifier",Spdx3ClassPropertyParameters {_propertyType = "anyURI", _minCount = Just 0, _maxCount = Just 1}),("lineRange",Spdx3ClassPropertyParameters {_propertyType = "positiveIntegerRange", _minCount = Just 0, _maxCount = Just 1}),("snippetPurpose",Spdx3ClassPropertyParameters {_propertyType = "SoftwarePurpose", _minCount = Just 0, _maxCount = Nothing})]}),("SoftwareDependencyRelationship",Spdx3Class {_classSummary = "MISSING", _classDescription = "TODO", _classMetadata = fromList [("Instantiability","Concrete"),("SubclassOf","Core:Relationship"),("name","SoftwareDependencyRelationship")], _classProperties = fromList [("linkType",Spdx3ClassPropertyParameters {_propertyType = "DependencyLinkType", _minCount = Just 1, _maxCount = Just 1}),("requirement",Spdx3ClassPropertyParameters {_propertyType = "DependencyRequirement", _minCount = Just 1, _maxCount = Just 1}),("scope",Spdx3ClassPropertyParameters {_propertyType = "DependencyScope", _minCount = Just 1, _maxCount = Just 1})]})]})]}